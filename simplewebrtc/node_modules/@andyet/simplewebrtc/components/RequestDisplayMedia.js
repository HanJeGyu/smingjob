"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const react_redux_1 = require("react-redux");
const Actions = tslib_1.__importStar(require("../actions"));
const Selectors_1 = require("../Selectors");
const Screensharing = tslib_1.__importStar(require("../lib/Screensharing"));
/**
 * @description
 *
 * @public
 *
 */
class RequestDisplayMedia extends React.Component {
    constructor(props) {
        super(props);
        this.installCheckInterval = undefined;
        this.state = {
            extensionInstalled: this.props.extensionId
                ? Screensharing.checkForExtensionSync(this.props.extensionId)
                : false,
            extensionInstalling: false,
            extensionRequired: Screensharing.requiresExtension()
        };
    }
    componentDidMount() {
        if (Screensharing.requiresExtension() && this.props.extensionId) {
            Screensharing.checkForExtension(this.props.extensionId).then(extensionInstalled => {
                this.setState({
                    extensionInstalled
                });
            });
        }
    }
    async getDisplayMedia() {
        try {
            if (!navigator.mediaDevices.getDisplayMedia) {
                throw new Error('getDisplayMedia not supported');
            }
            const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            const track = stream.getVideoTracks()[0];
            this.props.addLocalScreen(track, stream);
            if (this.props.share !== false) {
                this.props.shareLocalScreen(track.id);
            }
        }
        catch (err) {
            console.log(err, err.message, err.name);
        }
    }
    async listenForInstallation(interval = 2000) {
        if (this.installCheckInterval) {
            clearInterval(this.installCheckInterval);
            this.installCheckInterval = undefined;
        }
        this.setState({
            extensionInstalling: true
        });
        this.installCheckInterval = setInterval(() => {
            if (!this.props.extensionId || this.state.extensionInstalled) {
                clearInterval(this.installCheckInterval);
                this.installCheckInterval = undefined;
                return;
            }
            Screensharing.checkForExtension(this.props.extensionId).then(extensionInstalled => {
                this.setState({
                    extensionInstalled,
                    extensionInstalling: !extensionInstalled
                });
            });
        }, interval);
    }
    render() {
        if (this.props.render) {
            const available = Screensharing.isAvailable();
            const ready = available &&
                (!this.state.extensionRequired ||
                    (this.state.extensionRequired && this.state.extensionInstalled));
            return this.props.render(this.getDisplayMedia.bind(this), {
                available,
                extensionId: this.props.extensionId,
                extensionInstalled: this.state.extensionInstalled,
                extensionInstalling: this.state.extensionInstalling,
                extensionRequired: this.state.extensionRequired,
                listenForInstallation: this.listenForInstallation.bind(this),
                ready
            });
        }
        return React.createElement("button", { onClick: () => this.getDisplayMedia() }, "Start Screenshare");
    }
}
exports.RequestDisplayMedia = RequestDisplayMedia;
function mapStateToProps(state, ownProps) {
    const config = Selectors_1.getAPIConfig(state);
    return {
        extensionId: ownProps.extensionId || config.screensharingExtensions.chrome
    };
}
function mapDispatchToProps(dispatch) {
    return {
        addLocalScreen: (track, stream) => dispatch(Actions.addLocalScreen(track, stream)),
        shareLocalScreen: (id) => dispatch(Actions.shareLocalMedia(id))
    };
}
exports.default = react_redux_1.connect(mapStateToProps, mapDispatchToProps)(RequestDisplayMedia);
