"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("webrtc-adapter");
const realtime_text_1 = require("realtime-text");
const Stanza = tslib_1.__importStar(require("stanza"));
const Actions = tslib_1.__importStar(require("../actions"));
const Selectors = tslib_1.__importStar(require("../Selectors"));
const Mesh_1 = tslib_1.__importDefault(require("./Mesh"));
const MMUC_1 = tslib_1.__importDefault(require("./MMUC"));
class SignalingClient {
    constructor(dispatch, getState, opts) {
        this.logToConsole = localStorage.logxmpp || false;
        this.terminating = false;
        this.dispatch = dispatch;
        this.getState = getState;
        this.rttBuffers = new Map();
        this.xmpp = Stanza.createClient({
            transport: 'websocket',
            ...opts
        });
        this.xmpp.useStreamManagement = false;
        this.xmpp.sm.allowResume = false;
        this.jingle = this.xmpp.jingle;
        this.xmpp.use(MMUC_1.default);
        this.mesh = new Mesh_1.default(this);
        this.xmpp.use(this.mesh.plugin());
        this.xmpp.on('raw:*', (event, data) => {
            if (this.logToConsole) {
                console.log(event, data);
            }
        });
        this.xmpp.on('session:started', () => {
            this.xmpp.sendPresence();
            this.xmpp.enableKeepAlive({
                interval: 90
            });
            this.dispatch(Actions.connectionStateChanged('connected'));
        });
        this.xmpp.on('disconnected', () => {
            if (this.terminating) {
                return;
            }
            this.dispatch(Actions.connectionStateChanged('disconnected'));
            setTimeout(() => {
                const state = this.getState();
                const configUrl = Selectors.getConfigURL(state);
                const userData = Selectors.getUserToken(state);
                this.dispatch(Actions.connect(configUrl, userData));
            }, 1000 + Math.random() * 2000);
        });
        this.xmpp.on('muc:join', async (pres) => {
            const roomAddress = pres.from.bare;
            const state = this.getState();
            let room = Selectors.getRoomByAddress(state, roomAddress);
            if (!room) {
                return;
            }
            await this.checkLockStatus(roomAddress, room.providedPassword);
            this.dispatch(Actions.joinRoomSuccess(roomAddress, pres.from.full, pres.talkyUserInfo.roomId, pres.muc.role, pres.muc.affiliation));
            room = Selectors.getRoomByAddress(state, roomAddress);
            if (room && room.autoJoinCall) {
                this.dispatch(Actions.joinCall(roomAddress, Selectors.getDesiredMediaTypes(state, roomAddress)));
            }
        });
        this.xmpp.on('muc:failed', (pres) => {
            const roomAddress = pres.from.bare;
            const room = Selectors.getRoomByAddress(this.getState(), roomAddress);
            if (room && room.providedPassword && !room.passwordRequired) {
                this.joinRoom(roomAddress, undefined, room.autoJoinCall);
            }
            else {
                this.dispatch(Actions.joinRoomFailed(roomAddress, pres.error.condition === 'not-authorized'));
            }
        });
        this.xmpp.on('muc:error', (pres) => {
            this.dispatch(Actions.joinRoomFailed(pres.from.bare, pres.error.condition === 'not-authorized'));
        });
        this.xmpp.on('muc:available', (pres) => {
            const roomAddress = pres.from.bare;
            const peerAddress = pres.from.full;
            const state = this.getState();
            const room = Selectors.getRoomByAddress(state, roomAddress);
            if (!room) {
                return;
            }
            if (pres.muc.codes && pres.muc.codes.indexOf('110') >= 0) {
                this.dispatch(Actions.selfUpdated(roomAddress, peerAddress, room.id, pres.muc.role, pres.muc.affiliation));
                return;
            }
            if (!this.rttBuffers.has(peerAddress)) {
                const buffer = new realtime_text_1.DisplayBuffer(({ text }) => {
                    this.dispatch(Actions.peerUpdated(peerAddress, {
                        rtt: text
                    }));
                });
                this.rttBuffers.set(peerAddress, buffer);
            }
            const customerData = pres.talkyUserInfo.customerData || {};
            this.dispatch(Actions.peerOnline(roomAddress, peerAddress, {
                affiliation: pres.muc.affiliation,
                customerData,
                displayName: customerData.displayName || pres.nick,
                id: pres.talkyUserInfo.sessionId,
                joinedCall: !!pres.mmuc,
                requestingMedia: (pres.mmuc || {}).media,
                role: pres.muc.role
            }));
        });
        this.xmpp.on('muc:unavailable', (pres) => {
            if (pres.muc.codes && pres.muc.codes.indexOf('110') >= 0) {
                this.dispatch(Actions.leaveRoom(pres.from.bare));
                return;
            }
            this.rttBuffers.delete(pres.from.full);
            this.dispatch(Actions.peerOffline(pres.from.bare, pres.from.full));
        });
        this.xmpp.on('muc:destroyed', (pres) => {
            this.dispatch(Actions.leaveRoom(pres.from.bare));
        });
        this.xmpp.on('chat:state', (msg) => {
            this.dispatch(Actions.peerUpdated(msg.from.full, {
                chatState: msg.chatState
            }));
        });
        this.xmpp.on('attention', (msg) => {
            this.dispatch(Actions.peerUpdated(msg.from.full, {
                requestingAttention: true
            }));
            setTimeout(() => {
                this.dispatch(Actions.peerUpdated(msg.from.full, {
                    requestingAttention: false
                }));
            }, 5000);
        });
        this.xmpp.on('message', (msg) => {
            if (msg.type !== 'groupchat') {
                return;
            }
            if (msg.rtt) {
                const buffer = this.rttBuffers.get(msg.from.full);
                if (buffer) {
                    buffer.process(msg.rtt);
                }
            }
            if (msg.body) {
                const buffer = this.rttBuffers.get(msg.from.full);
                if (buffer) {
                    buffer.commit();
                }
                this.dispatch(Actions.receiveChat(msg.from.bare, msg.from.full, {
                    body: msg.body,
                    displayName: msg.nick,
                    id: msg.id,
                    replace: msg.replace,
                    time: msg.delay ? msg.delay.stamp : new Date()
                }));
            }
        });
        this.xmpp.on('message', (msg) => this.processMessage(msg));
    }
    connect() {
        this.xmpp.connect();
    }
    disconnect() {
        this.terminating = true;
        this.dispatch(Actions.connectionStateChanged('disconnected'));
        this.xmpp.disconnect();
    }
    joinRoom(roomAddress, password, autoJoinCall) {
        const state = this.getState();
        const config = Selectors.getAPIConfig(state);
        const displayName = Selectors.getUserDisplayName(state);
        const opts = {
            joinMuc: {
                password
            },
            nick: displayName
        };
        this.xmpp.joinRoom(roomAddress, config.id, opts);
        if (autoJoinCall !== false) {
            this.dispatch(Actions.joinCall(roomAddress, Selectors.getDesiredMediaTypes(state, roomAddress)));
        }
    }
    async destroyRoom(roomAddress) {
        await this.xmpp.destroyRoom(roomAddress);
    }
    sendRoomPresence(roomAddress, opts = {}) {
        const state = this.getState();
        const displayName = Selectors.getUserDisplayName(state);
        const room = Selectors.getRoomByAddress(state, roomAddress);
        const call = Selectors.getCallForRoom(state, roomAddress);
        const media = Selectors.getDesiredMediaTypes(state, roomAddress);
        if (!room || !room.joined) {
            return;
        }
        this.xmpp.sendPresence({
            mmuc: call && call.joined
                ? {
                    media
                }
                : undefined,
            nick: displayName || true,
            to: roomAddress,
            ...opts
        });
    }
    sendAllRoomsPresence(opts = {}) {
        const state = this.getState();
        const rooms = Object.keys(Selectors.getRooms(state));
        for (const roomAddress of rooms) {
            this.sendRoomPresence(roomAddress, opts);
        }
    }
    sendAllCallsSpeakingUpdate(speaking) {
        const state = this.getState();
        const calls = Selectors.getJoinedCalls(state);
        for (const call of calls) {
            this.xmpp.sendMessage({
                mmuc: {
                    speaking
                },
                to: call.roomAddress,
                type: 'groupchat'
            });
        }
    }
    async lockRoom(roomAddress, password) {
        const state = this.getState();
        const room = Selectors.getRoomByAddress(state, roomAddress);
        if (!room || !room.joined || room.selfAffiliation !== 'owner') {
            return;
        }
        try {
            await this.xmpp.configureRoom(roomAddress, {
                fields: [
                    {
                        name: 'FORM_TYPE',
                        value: 'http://jabber.org/protocol/muc#roomconfig'
                    },
                    {
                        name: 'muc#roomconfig_whois',
                        type: 'text-single',
                        value: 'moderators'
                    },
                    {
                        name: 'muc#roomconfig_roomsecret',
                        type: 'text-single',
                        value: password
                    },
                    {
                        name: 'muc#roomconfig_passwordprotectedroom',
                        type: 'boolean',
                        value: '1'
                    }
                ]
            });
            this.dispatch(Actions.roomLocked(roomAddress, password));
        }
        catch (err) {
            console.error(err);
        }
    }
    async unlockRoom(roomAddress) {
        const state = this.getState();
        const room = Selectors.getRoomByAddress(state, roomAddress);
        if (!room || !room.joined || room.selfAffiliation !== 'owner') {
            return;
        }
        try {
            await this.xmpp.configureRoom(roomAddress, {
                fields: [
                    {
                        name: 'FORM_TYPE',
                        value: 'http://jabber.org/protocol/muc#roomconfig'
                    },
                    {
                        name: 'muc#roomconfig_whois',
                        type: 'text-single',
                        value: 'moderators'
                    },
                    {
                        name: 'muc#roomconfig_roomsecret',
                        type: 'text-single',
                        value: ''
                    },
                    {
                        name: 'muc#roomconfig_passwordprotectedroom',
                        type: 'boolean',
                        value: '1'
                    }
                ]
            });
            this.dispatch(Actions.roomUnlocked(roomAddress));
        }
        catch (err) {
            console.error(err);
        }
    }
    async fetchRoomConfig(roomAddress, initial = false) {
        const config = {};
        const state = this.getState();
        const room = Selectors.getRoomByAddress(state, roomAddress);
        if (!initial && (!room || !room.joined)) {
            throw new Error('Room not joined');
        }
        const res = await this.xmpp.getRoomConfig(roomAddress);
        const form = res.mucOwner.form;
        for (const field of form.fields) {
            if (field.name === 'muc#roomconfig_roomsecret') {
                if (field.value) {
                    config.password = field.value;
                }
                else {
                    config.password = undefined;
                }
            }
        }
        return config;
    }
    async checkLockStatus(roomAddress, providedPassword, forceInfo) {
        const room = Selectors.getRoomByAddress(this.getState(), roomAddress);
        if (!room) {
            return;
        }
        if (room.selfAffiliation === 'owner' && !forceInfo) {
            try {
                const config = await this.fetchRoomConfig(roomAddress, true);
                if (config.password) {
                    this.dispatch(Actions.roomLocked(roomAddress, config.password));
                }
                else if (providedPassword) {
                    this.dispatch(Actions.lockRoom(roomAddress, providedPassword));
                }
                else {
                    this.dispatch(Actions.roomUnlocked(roomAddress));
                }
            }
            catch (err) {
                console.error(err);
                return this.checkLockStatus(roomAddress, providedPassword, true);
            }
        }
        else {
            try {
                const res = await this.xmpp.getDiscoInfo(roomAddress);
                if (res.discoInfo.features.indexOf('muc_passwordprotected') >= 0) {
                    this.dispatch(Actions.roomLocked(roomAddress));
                }
                else {
                    this.dispatch(Actions.roomUnlocked(roomAddress));
                }
            }
            catch (err) {
                console.error(err);
            }
        }
    }
    async processMessage(msg) {
        const roomAddress = msg.from.bare;
        const room = Selectors.getRoomByAddress(this.getState(), roomAddress);
        if (msg.type === 'groupchat' && msg.mmuc) {
            if (room && room.selfAddress !== msg.from.full && msg.mmuc) {
                this.dispatch(Actions.peerUpdated(msg.from.full, {
                    speaking: msg.mmuc.speaking || false
                }));
            }
        }
        if (msg.muc && msg.muc.codes && msg.muc.codes.indexOf('104') >= 0) {
            await this.checkLockStatus(roomAddress);
        }
    }
}
exports.default = SignalingClient;
