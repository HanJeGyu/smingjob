"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Actions = tslib_1.__importStar(require("../actions"));
const Selectors = tslib_1.__importStar(require("../Selectors"));
function createIceServerConfig(server) {
    let host = server.host;
    if (host.indexOf(':') >= 0) {
        host = `[${host}]`;
    }
    let uri = `${server.type}:${host}`;
    if (server.port) {
        uri += `:${server.port}`;
    }
    if (server.transport) {
        uri += `?transport=${server.transport}`;
    }
    if (server.type === 'turn' || server.type === 'turns') {
        return {
            credential: server.password,
            urls: [uri],
            username: server.username
        };
    }
    return { urls: [uri] };
}
class Mesh {
    constructor(client) {
        this.jingle = client.jingle;
        this.dispatch = client.dispatch;
        this.getState = client.getState;
        this.updateICEServers();
        this.jingle.config.peerConnectionConfig.sdpSemantics = 'plan-b';
    }
    updateICEServers() {
        this.jingle.resetICEServers();
        const config = Selectors.getAPIConfig(this.getState());
        for (const server of config.iceServers) {
            this.jingle.addICEServer(createIceServerConfig(server));
        }
    }
    updateConnections() {
        if (!RTCPeerConnection) {
            return;
        }
        const state = this.getState();
        const videoPeersCount = Selectors.countPeersWantingVideo(state);
        const calls = Selectors.getJoinedCalls(state);
        const media = Selectors.getMedia(state);
        const sharedMedia = Selectors.getSharedMedia(state);
        const sharedVideoCount = sharedMedia.filter(m => m.kind === 'video').length;
        const activeCalls = new Set();
        for (const call of calls) {
            if (call.joined) {
                activeCalls.add(call.roomAddress);
            }
        }
        const videoResolutionTiers = Selectors.getVideoResolutionTiers(state);
        let appliedTier = videoResolutionTiers[0];
        for (let i = 0; i < videoResolutionTiers.length; i++) {
            const tier = videoResolutionTiers[i];
            const nextTier = videoResolutionTiers[i + 1];
            if (tier[0] === videoPeersCount || !nextTier) {
                appliedTier = tier;
                break;
            }
            if (nextTier[0] > videoPeersCount) {
                appliedTier = tier;
                break;
            }
        }
        if (appliedTier) {
            const { width, height, frameRate } = appliedTier[1];
            this.dispatch(Actions.adjustVideoCaptureResolution(width, height, frameRate));
        }
        // The total bandwidth we want to send depends on the number of outgoing
        // video tracks. It is specified in kilobits per second.
        const maximumBitrate = 1800000 / (videoPeersCount * sharedVideoCount);
        // Dispose of any orphaned connections after leaving a call
        const allConnections = Selectors.getConnections(state);
        for (const connId of Object.keys(allConnections)) {
            const conn = allConnections[connId];
            const sess = this.jingle.sessions[conn.id];
            if (sess && !activeCalls.has(conn.roomAddress)) {
                sess.end();
            }
        }
        for (const call of calls) {
            const peers = Selectors.getPeersForCall(state, call.roomAddress);
            for (const peer of peers) {
                const needsVideo = new Set();
                const needsAudio = new Set();
                const wantsVideo = peer.requestingMedia === 'video';
                const wantsAudio = peer.requestingMedia === 'video' || peer.requestingMedia === 'audio';
                const peerSharedMedia = new Map();
                const overSharedSessions = new Set();
                const connections = Selectors.getConnectionsForPeer(state, peer.address);
                for (const conn of connections) {
                    if (conn.sendingAudioMediaId) {
                        peerSharedMedia.set(conn.sendingAudioMediaId, 'audio');
                        if (!wantsAudio ||
                            !media[conn.sendingAudioMediaId] ||
                            !media[conn.sendingAudioMediaId].shared) {
                            overSharedSessions.add(conn.id);
                            if (conn.sendingVideoMediaId && wantsVideo) {
                                needsVideo.add(conn.sendingVideoMediaId);
                            }
                        }
                    }
                    if (conn.sendingVideoMediaId) {
                        const sess = this.jingle.sessions[conn.id];
                        if (sess) {
                            sess.setMaximumBitrate(maximumBitrate);
                        }
                        peerSharedMedia.set(conn.sendingVideoMediaId, 'video');
                        const video = media[conn.sendingVideoMediaId];
                        if ((!wantsVideo && !video.screenCapture) || !video || !video.shared) {
                            overSharedSessions.add(conn.id);
                            if (conn.sendingAudioMediaId && wantsAudio) {
                                needsAudio.add(conn.sendingAudioMediaId);
                            }
                        }
                    }
                }
                for (const track of sharedMedia) {
                    if (!peerSharedMedia.has(track.id)) {
                        if (track.kind === 'audio' && wantsAudio) {
                            needsAudio.add(track.id);
                        }
                        if (track.kind === 'video' && wantsVideo) {
                            needsVideo.add(track.id);
                        }
                        if (track.kind === 'video' && track.screenCapture && wantsAudio) {
                            needsVideo.add(track.id);
                        }
                    }
                }
                for (const sessionId of overSharedSessions) {
                    const session = this.jingle.sessions[sessionId];
                    if (session) {
                        session.end();
                    }
                }
                const pairedTracks = new Map();
                for (const id of [...needsAudio, ...needsVideo]) {
                    const track = media[id];
                    if (track) {
                        const pair = pairedTracks.get(track.stream.id) || {};
                        pair[track.kind] = track;
                        pairedTracks.set(track.stream.id, pair);
                    }
                }
                for (const pair of pairedTracks.values()) {
                    const session = this.jingle.createMediaSession(peer.address);
                    if (pair.audio) {
                        session.addTrack(pair.audio.track, pair.audio.stream);
                        this.dispatch(Actions.updateConnection(peer.address, session.sid, {
                            sendingAudioMediaId: pair.audio.id
                        }));
                    }
                    if (pair.video) {
                        session.addTrack(pair.video.track, pair.video.stream);
                        this.dispatch(Actions.updateConnection(peer.address, session.sid, {
                            sendingVideoMediaId: pair.video.id
                        }));
                    }
                    session.start({
                        offerToReceiveAudio: false,
                        offerToReceiveVideo: false
                    }, () => {
                        if (pair.video) {
                            session.setMaximumBitrate(maximumBitrate);
                        }
                        if (pair.audio && pair.audio.localDisabled) {
                            session.mute(session.role, 'audio');
                        }
                        if (pair.video && pair.video.localDisabled) {
                            session.mute(session.role, 'video');
                        }
                        if (pair.video && pair.video.screenCapture) {
                            session.send('description-info', {
                                contents: [
                                    {
                                        application: {
                                            applicationType: 'rtp',
                                            screenCaptures: [{ id: pair.video.id }]
                                        },
                                        name: 'video'
                                    }
                                ]
                            });
                        }
                    });
                }
            }
        }
    }
    plugin() {
        return () => {
            this.jingle.on('incoming', (session) => {
                const state = this.getState();
                const call = Selectors.getCallForRoom(state, session.peerID.split('/')[0]);
                if (call && call.joined) {
                    session.accept();
                }
                else {
                    session.end();
                }
                session.onDescriptionInfo = (changes, cb) => {
                    const connections = Selectors.getConnections(this.getState());
                    for (const content of changes.contents || []) {
                        if (content.application &&
                            content.application.screenCaptures &&
                            content.application.screenCaptures.length) {
                            this.dispatch(Actions.updateMedia(connections[session.sid].receivingVideoMediaId, {
                                screenCapture: true
                            }));
                        }
                    }
                    cb();
                };
            });
            this.jingle.on('terminated', (session, reason) => {
                this.dispatch(Actions.removeConnection(session.peerID, session.sid));
                if (reason.condition && reason.condition !== 'success' && reason.condition !== 'gone') {
                    console.error('Session terminated with error:', session.sid, reason);
                    this.dispatch(Actions.peerUpdated(session.peerID, {
                        sessionFailed: true
                    }));
                }
                // Probably terminated session because the peer is gone. Give the rest of
                // the system a chance to update before attempting to restart connections.
                setTimeout(() => {
                    this.updateConnections();
                }, 1000);
            });
            this.jingle.on('createdSession', (session) => {
                this.dispatch(Actions.addConnection(session.peerID, session.sid));
                session.on('peerTrackAdded', (_, track, stream) => {
                    // Track IDs can get reused across sessions, so we prefix with the session ID for
                    // remote tracks. Local tracks always have unique IDs.
                    const remoteTrackId = `${session.sid}#${track.id}`;
                    this.dispatch(Actions.addRemoteMedia(session.peerID.split('/')[0], session.peerID, remoteTrackId, track, stream, false));
                    if (track.kind === 'audio') {
                        this.dispatch(Actions.updateConnection(session.peerID, session.sid, {
                            receivingAudioMediaId: remoteTrackId
                        }));
                    }
                    if (track.kind === 'video') {
                        this.dispatch(Actions.updateConnection(session.peerID, session.sid, {
                            receivingVideoMediaId: remoteTrackId
                        }));
                    }
                });
                session.on('peerTrackRemoved', (_, track) => {
                    // Track IDs can get reused across sessions, so we prefix with the session ID for
                    // remote tracks. Local tracks always have unique IDs.
                    const remoteTrackId = `${session.sid}#${track.id}`;
                    this.dispatch(Actions.removeMedia(remoteTrackId));
                });
                session.on('connectionState', () => {
                    this.dispatch(Actions.updateConnection(session.peerID, session.sid, {
                        connectionState: session.connectionState,
                        restarting: session.restartingIce,
                        sessionState: session.state
                    }));
                    if (session.connectionState === 'connected') {
                        this.dispatch(Actions.peerUpdated(session.peerID, {
                            sessionFailed: false
                        }));
                    }
                    // Responder side doesn't restart ICE. Give initiator a chance, but do eventually end.
                    if ((session.role === 'responder' && session.connectionState === 'disconnected') ||
                        session.connectionState === 'interrupted') {
                        setTimeout(() => {
                            if (session.connectionState === 'disconnected' ||
                                session.connectionState === 'interrupted') {
                                session.end('failed-transport');
                            }
                        }, 5000);
                    }
                });
                session.on('sessionState', () => {
                    this.dispatch(Actions.updateConnection(session.peerID, session.sid, {
                        connectionState: session.connectionState,
                        restarting: session.restartingIce,
                        sessionState: session.state
                    }));
                });
            });
            this.jingle.on('mute', (session, info) => {
                const state = this.getState();
                const connections = Selectors.getConnections(state);
                if (info.name === 'audio') {
                    this.dispatch(Actions.updateMedia(connections[session.sid].receivingAudioMediaId, {
                        remoteDisabled: true
                    }));
                }
                else if (info.name === 'video') {
                    this.dispatch(Actions.updateMedia(connections[session.sid].receivingVideoMediaId, {
                        remoteDisabled: true
                    }));
                }
                else {
                    throw new Error('Invalid mute property');
                }
            });
            this.jingle.on('unmute', (session, info) => {
                const state = this.getState();
                const connections = Selectors.getConnections(state);
                if (info.name === 'audio') {
                    this.dispatch(Actions.updateMedia(connections[session.sid].receivingAudioMediaId, {
                        remoteDisabled: false
                    }));
                }
                else if (info.name === 'video') {
                    this.dispatch(Actions.updateMedia(connections[session.sid].receivingVideoMediaId, {
                        remoteDisabled: false
                    }));
                }
                else {
                    throw new Error('Invalid mute property');
                }
            });
        };
    }
    notifyPeers(media, action) {
        const state = this.getState();
        const connections = Selectors.getConnections(state);
        Object.values(Selectors.getClient(state).jingle.sessions).forEach((session) => {
            const conn = connections[session.sid];
            if (conn &&
                (conn.sendingAudioMediaId === media.id || conn.sendingVideoMediaId === media.id)) {
                session[action](session.role, media.kind);
            }
        });
    }
}
exports.default = Mesh;
