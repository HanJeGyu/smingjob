import { combineReducers, createStore as createStore$1, compose, applyMiddleware } from 'redux';
import Thunk from 'redux-thunk';
import webrtc from 'webrtc-adapter';
import { DisplayBuffer, InputBuffer } from 'realtime-text';
import { createClient, jid } from 'stanza';
import 'events';
import { v4 } from 'uuid';
import { Component, createElement, Fragment } from 'react';
import { connect as connect$1 } from 'react-redux';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

// Action Names
// ====================================================================
const SET_USER_PREFERENCE = '@andyet/SET_USER_PREFERENCE';
const JOIN_ROOM = '@andyet/JOIN_ROOM';
const LEAVE_ROOM = '@andyet/LEAVE_ROOM';
const LOCK_ROOM = '@andyet/LOCK_ROOM';
const UNLOCK_ROOM = '@andyet/UNLOCK_ROOM';
const DESTROY_ROOM = '@andyet/DESTROY_ROOM';
const SELF_UPDATED = '@andyet/SELF_UPDATED';
const JOIN_ROOM_FAILED = '@andyet/JOIN_ROOM_FAILED';
const JOIN_ROOM_SUCCESS = '@andyet/JOIN_ROOM_SUCCESS';
const ROOM_LOCKED = '@andyet/ROOM_LOCKED';
const ROOM_UNLOCKED = '@andyet/ROOM_UNLOCKED';
const KICK_PEER = '@andyet/KICK_PEER';
const PEER_ONLINE = '@andyet/PEER_ONLINE';
const PEER_OFFLINE = '@andyet/PEER_OFFLINE';
const PEER_UPDATED = '@andyet/PEER_UPDATED';
const CHAT_INCOMING = '@andyet/CHAT_INCOMING';
const CHAT_OUTGOING = '@andyet/CHAT_OUTGOING';
const CHAT_STATE_OUTGOING = '@andyet/CHAT_STATE_OUTGOING';
const RTT_OUTGOING = '@andyet/RTT_OUTGOING';
const ADD_MEDIA = '@andyet/ADD_MEDIA';
const REMOVE_MEDIA = '@andyet/REMOVE_MEDIA';
const MEDIA_UPDATED = '@andyet/MEDIA_UPDATED';
const SIGNALING_CLIENT = '@andyet/SIGNALING_CLIENT';
const SIGNALING_CLIENT_SHUTDOWN = '@andyet/SIGNALING_CLIENT_SHUTDOWN';
const CONNECTION_STATE_CHANGE = '@andyet/CONNECTION_STATE_CHANGE';
const RECEIVED_CONFIG = '@andyet/RECEIVED_CONFIG';
const RECEIVED_CONFIG_ERROR = '@andyet/RECEIVED_CONFIG_ERROR';
const QUEUE_TELEMETRY = '@andyet/QUEUE_TELEMETRY';
const TELEMETRY_SUCCESS = '@andyet/TELEMETRY_SUCCESS';
const JOIN_CALL = '@andyet/JOIN_CALL';
const LEAVE_CALL = '@andyet/LEAVE_CALL';
const SET_CALL_PREFERENCE = '@andyt/SET_CALL_PREFERENCE';
const PEER_CONNECTION_UPDATED = '@andyet/PEER_CONNECTION_UPDATED';
const PEER_CONNECTION_ADDED = '@andyet/PEER_CONNECTION_ADDED';
const PEER_CONNECTION_REMOVED = '@andyet/PEER_CONNECTION_REMOVED';
const DEVICES = '@andyet/DEVICES';
const CAMERA_PERMISSION_DENIED = '@andyet/CAMERA_PERMISSION_DENIED';
const MICROPHONE_PERMISSION_DENIED = '@andyet/MICROPHONE_PERMISSION_DENIED';
const DEVICE_CAPTURE = '@andyet/DEVICE_CAPTURE';
const SET_VIDEO_RESOLUTION_TIERS = '@andyet/SET_VIDEO_RESOLUTION_TIERS';
// Constants
// ====================================================================
const SDK_VERSION = '1.14.4';
const DIRECTION_INCOMING = 'incoming';
const DIRECTION_OUTGOING = 'outgoing';

// getConnectionForMedia
/**
 * @description
 *
 * @public
 *
 */
function getAPIConfig(state) {
    return state.simplewebrtc.api.config;
}
/**
 * @description
 *
 * @public
 *
 */
function getUserToken(state) {
    return state.simplewebrtc.api.token;
}
/**
 * @description
 *
 * @public
 *
 */
function getUser(state) {
    return state.simplewebrtc.user;
}
/**
 * @description
 *
 * @public
 *
 */
function getUserCustomerData(state) {
    return getAPIConfig(state).customerData;
}
/**
 * @description
 *
 * @public
 *
 */
function getConfigURL(state) {
    return state.simplewebrtc.api.configUrl;
}
/**
 * @description
 *
 * @public
 *
 */
function getClient(state) {
    return state.simplewebrtc.api.signalingClient;
}
/**
 * @description
 *
 * @public
 *
 */
function getQueuedTelemetry(state) {
    return state.simplewebrtc.api.queuedTelemetry;
}
/**
 * @description
 *
 * @public
 *
 */
function getConnectionState(state) {
    return state.simplewebrtc.api.connectionState;
}
/**
 * @description
 *
 * @public
 *
 */
function getUserDisplayName(state) {
    return state.simplewebrtc.user.displayName;
}
/**
 * @description
 *
 * @public
 *
 */
function getUserDataForRoom(state, roomAddress) {
    const config = getAPIConfig(state);
    const room = getRoomByAddress(state, roomAddress);
    const call = getCallForRoom(state, roomAddress);
    const localAudio = getLocalMedia(state, 'audio');
    const recentSpeaking = localAudio
        .filter(a => a.lastSpokeAt)
        .sort((a, b) => {
        const lastA = a.lastSpokeAt ? a.lastSpokeAt.valueOf() : 0;
        const lastB = b.lastSpokeAt ? b.lastSpokeAt.valueOf() : 0;
        return lastA - lastB;
    });
    return {
        address: room.selfAddress,
        affiliation: room.selfAffiliation,
        chatState: 'active',
        customerData: getAPIConfig(state).customerData,
        displayName: getUserDisplayName(state),
        id: config.id,
        joinedCall: call.joined,
        joinedCallAt: call.joinedAt,
        joinedRoomAt: room.joinedAt,
        lastSpokeAt: recentSpeaking.length ? recentSpeaking[0].lastSpokeAt : undefined,
        muted: false,
        requestingAttention: false,
        requestingMedia: getDesiredMediaTypes(state, roomAddress),
        role: room.selfRole,
        roomAddress,
        rtt: '',
        speaking: userIsSpeaking(state, true),
        volume: 0,
        volumeLimit: 0.8
    };
}
/**
 * @description
 *
 * @public
 *
 */
function getDesiredMediaTypes(state, roomAddress) {
    const defaultRequest = state.simplewebrtc.user.requestingMedia;
    if (roomAddress) {
        const call = getCallForRoom(state, roomAddress);
        if (call) {
            return call.requestingMedia || defaultRequest;
        }
    }
    return defaultRequest;
}
/**
 * @description
 *
 * @public
 *
 */
function getPushToTalkEnabled(state) {
    return state.simplewebrtc.user.pushToTalk;
}
/**
 * @description
 *
 * @public
 *
 */
function getPeerByAddress(state, peerAddress) {
    return state.simplewebrtc.peers[peerAddress];
}
/**
 * @description
 *
 * @public
 *
 */
function getRooms(state) {
    return state.simplewebrtc.rooms;
}
/**
 * @description
 *
 * @public
 *
 */
function getRoomByAddress(state, roomAddress) {
    return state.simplewebrtc.rooms[roomAddress];
}
/**
 * @description
 *
 * @public
 *
 */
function getRoomByProvidedName(state, roomName) {
    for (const roomAddress of Object.keys(state.simplewebrtc.rooms)) {
        if (state.simplewebrtc.rooms[roomAddress].providedName === roomName) {
            return state.simplewebrtc.rooms[roomAddress];
        }
    }
}
/**
 * @description
 *
 * @public
 *
 */
function getPeersForRoom(state, roomAddress) {
    const peers = [];
    for (const peerAddress of Object.keys(state.simplewebrtc.peers)) {
        if (state.simplewebrtc.peers[peerAddress].roomAddress === roomAddress) {
            peers.push(state.simplewebrtc.peers[peerAddress]);
        }
    }
    return peers;
}
/**
 * @description
 *
 * @public
 *
 */
function getChatsForRoom(state, roomAddress) {
    const chats = [];
    for (const id of Object.keys(state.simplewebrtc.chats)) {
        const chat = state.simplewebrtc.chats[id];
        if (chat.roomAddress === roomAddress) {
            chats.push(chat);
        }
    }
    return chats.sort((a, b) => (a.time < b.time ? -1 : a.time > b.time ? 1 : 0));
}
/**
 * @description
 *
 * @public
 *
 */
function getGroupedChatsForRoom(state, roomAddress, maxDuration = 5 * 60) {
    const groupedChats = [];
    const chats = getChatsForRoom(state, roomAddress);
    let lastGroup;
    for (const chat of chats) {
        const newSender = !lastGroup || chat.senderAddress !== lastGroup.senderAddress;
        const prevChat = lastGroup ? lastGroup.chats[lastGroup.chats.length - 1] : undefined;
        const newDisplayName = !lastGroup || (prevChat && chat.displayName && chat.displayName !== prevChat.displayName);
        let expired = false;
        if (maxDuration) {
            // Also start a new group if the current group has lasted for a significant amount of time.
            expired =
                !lastGroup || Number(chat.time) > Number(lastGroup.chats[0].time) + maxDuration * 1000;
        }
        if (newSender || newDisplayName || expired) {
            let peer = getPeerByAddress(state, chat.senderAddress) || {};
            if (chat.direction === 'outgoing') {
                peer = getUserDataForRoom(state, roomAddress);
            }
            lastGroup = {
                chats: [chat],
                direction: chat.direction,
                displayName: peer.displayName || chat.displayName,
                endTime: chat.time,
                peer,
                senderAddress: chat.senderAddress,
                startTime: chat.time
            };
            groupedChats.push(lastGroup);
        }
        else if (lastGroup) {
            lastGroup.chats.push(chat);
            lastGroup.endTime = chat.time;
        }
    }
    return groupedChats;
}
/**
 * @description
 *
 * @public
 *
 */
function getLastSentChat(state, roomAddress) {
    const chats = getChatsForRoom(state, roomAddress);
    return chats.filter(c => c.direction === DIRECTION_OUTGOING).slice(-1)[0];
}
/**
 * @description
 *
 * @public
 *
 */
function getChatComposers(state, roomAddress) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.peers)) {
        const peer = state.simplewebrtc.peers[id];
        if (peer.roomAddress === roomAddress && peer.chatState === 'composing') {
            results.push(peer);
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function getCallForRoom(state, roomAddress) {
    return state.simplewebrtc.calls[roomAddress];
}
/**
 * @description
 *
 * @public
 *
 */
function getMedia(state) {
    return state.simplewebrtc.media;
}
/**
 * @description
 *
 * @public
 *
 */
function getMediaTrack(state, id) {
    return state.simplewebrtc.media[id];
}
/**
 * @description
 *
 * @public
 *
 */
function getDeviceForMediaTrack(state, id) {
    const track = getMediaTrack(state, id);
    if (!track) {
        return;
    }
    let deviceId;
    const deviceLabel = track.track.label;
    const deviceKind = `${track.kind}input`;
    if (track.track.getSettings) {
        const settings = track.track.getSettings();
        deviceId = settings.deviceId;
    }
    const devices = state.simplewebrtc.devices.devices;
    if (deviceId) {
        for (const device of devices) {
            if (device.deviceId === deviceId) {
                return device;
            }
        }
    }
    for (const device of devices) {
        if (deviceLabel === device.label && deviceKind === device.kind) {
            return device;
        }
    }
}
/**
 * @description
 *
 * @public
 *
 */
function getDevices(state, kind) {
    const devices = state.simplewebrtc.devices.devices;
    if (!kind) {
        return devices;
    }
    return devices.filter(device => device.kind === kind);
}
/**
 * @description
 *
 * @public
 *
 */
function getDevicePermissions(state) {
    const devices = state.simplewebrtc.devices;
    return {
        cameraPermissionDenied: devices.cameraPermissionDenied,
        cameraPermissionGranted: devices.cameraPermissionGranted,
        hasAudioOutput: devices.hasAudioOutput,
        hasCamera: devices.hasCamera,
        hasMicrophone: devices.hasMicrophone,
        microphonePermissionDenied: devices.microphonePermissionDenied,
        microphonePermissionGranted: devices.microphonePermissionGranted,
        requestingCameraCapture: devices.requestingCameraCapture,
        requestingCapture: devices.requestingCapture,
        requestingMicrophoneCapture: devices.requestingMicrophoneCapture
    };
}
/**
 * @description
 *
 * @public
 *
 */
function getMediaForPeer(state, peerAddress, kind) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.media)) {
        const media = state.simplewebrtc.media[id];
        if (media.owner === peerAddress) {
            if (!kind || kind === media.kind) {
                results.push(media);
            }
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function getLocalMedia(state, kind) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.media)) {
        const media = state.simplewebrtc.media[id];
        if (media.source === 'local') {
            if (!kind || kind === media.kind) {
                results.push(media);
            }
        }
    }
    return results.sort((a, b) => a.createdAt - b.createdAt);
}
/**
 * @description
 *
 * @public
 *
 */
function getRemoteMedia(state, kind) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.media)) {
        const media = state.simplewebrtc.media[id];
        if (media.source === 'remote') {
            if (!kind || kind === media.kind) {
                results.push(media);
            }
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function getSharedMedia(state, kind) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.media)) {
        const media = state.simplewebrtc.media[id];
        if (media.source === 'local' && media.shared) {
            if (!kind || kind === media.kind) {
                results.push(media);
            }
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function getAudioOutputDevice(state) {
    return state.simplewebrtc.user.audioOutputDeviceId;
}
/**
 * @description
 *
 * @public
 *
 */
function getGlobalVolumeLimit(state) {
    return state.simplewebrtc.user.globalVolumeLimit;
}
/**
 * @description
 *
 * @public
 *
 */
function getJoinedCalls(state) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.calls)) {
        const call = state.simplewebrtc.calls[id];
        const room = getRoomByAddress(state, call.roomAddress);
        if (call.joined && room && room.joined) {
            results.push(call);
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function getPeersForCall(state, roomAddress) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.peers)) {
        const peer = state.simplewebrtc.peers[id];
        if (peer.roomAddress === roomAddress && peer.joinedCall) {
            results.push(peer);
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function getActiveSpeakersForCall(state, roomAddress) {
    const results = [];
    for (const id of Object.keys(state.simplewebrtc.peers)) {
        const peer = state.simplewebrtc.peers[id];
        if (peer.roomAddress === roomAddress && peer.joinedCall && peer.speaking) {
            results.push(peer);
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function getConnections(state) {
    return state.simplewebrtc.connections;
}
/**
 * @description
 *
 * @public
 *
 */
function getConnectionsForPeer(state, peerAddress) {
    const results = [];
    const connections = getConnections(state);
    for (const id of Object.keys(connections)) {
        const connection = connections[id];
        if (connection.peerAddress === peerAddress) {
            results.push(connection);
        }
    }
    return results;
}
/**
 * @description
 *
 * @public
 *
 */
function countPeersWantingVideo(state) {
    let count = 0;
    for (const id of Object.keys(state.simplewebrtc.peers)) {
        const peer = state.simplewebrtc.peers[id];
        if (peer.requestingMedia === 'video') {
            count += 1;
        }
    }
    return count;
}
/**
 * @description
 *
 * @public
 */
function isSupportedBrowser(state) {
    return !!('RTCPeerConnection' in window) && !!('mediaDevices' in navigator);
}
/**
 * @description
 *
 * @private
 */
function userIsSpeaking(state, sharedAudioOnly = true) {
    const localAudio = getLocalMedia(state, 'audio');
    return (localAudio.filter(a => !a.localDisabled && !a.externalDisabled && a.speaking && (sharedAudioOnly ? a.shared : true)).length > 0);
}
/**
 * @description
 *
 * @private
 */
function userIsSpeakingWhileMuted(state, sharedAudioOnly = true) {
    const localAudio = getLocalMedia(state, 'audio');
    return (localAudio.filter(a => (a.localDisabled || a.externalDisabled) && a.speaking && (sharedAudioOnly ? a.shared : true)).length > 0);
}
/**
 * @description
 *
 * @private
 */
function getVideoResolutionTiers(state) {
    return state.simplewebrtc.api.videoResolutionTiers || [];
}

var Selectors = /*#__PURE__*/Object.freeze({
    getAPIConfig: getAPIConfig,
    getUserToken: getUserToken,
    getUser: getUser,
    getUserCustomerData: getUserCustomerData,
    getConfigURL: getConfigURL,
    getClient: getClient,
    getQueuedTelemetry: getQueuedTelemetry,
    getConnectionState: getConnectionState,
    getUserDisplayName: getUserDisplayName,
    getUserDataForRoom: getUserDataForRoom,
    getDesiredMediaTypes: getDesiredMediaTypes,
    getPushToTalkEnabled: getPushToTalkEnabled,
    getPeerByAddress: getPeerByAddress,
    getRooms: getRooms,
    getRoomByAddress: getRoomByAddress,
    getRoomByProvidedName: getRoomByProvidedName,
    getPeersForRoom: getPeersForRoom,
    getChatsForRoom: getChatsForRoom,
    getGroupedChatsForRoom: getGroupedChatsForRoom,
    getLastSentChat: getLastSentChat,
    getChatComposers: getChatComposers,
    getCallForRoom: getCallForRoom,
    getMedia: getMedia,
    getMediaTrack: getMediaTrack,
    getDeviceForMediaTrack: getDeviceForMediaTrack,
    getDevices: getDevices,
    getDevicePermissions: getDevicePermissions,
    getMediaForPeer: getMediaForPeer,
    getLocalMedia: getLocalMedia,
    getRemoteMedia: getRemoteMedia,
    getSharedMedia: getSharedMedia,
    getAudioOutputDevice: getAudioOutputDevice,
    getGlobalVolumeLimit: getGlobalVolumeLimit,
    getJoinedCalls: getJoinedCalls,
    getPeersForCall: getPeersForCall,
    getActiveSpeakersForCall: getActiveSpeakersForCall,
    getConnections: getConnections,
    getConnectionsForPeer: getConnectionsForPeer,
    countPeersWantingVideo: countPeersWantingVideo,
    isSupportedBrowser: isSupportedBrowser,
    userIsSpeaking: userIsSpeaking,
    userIsSpeakingWhileMuted: userIsSpeakingWhileMuted,
    getVideoResolutionTiers: getVideoResolutionTiers
});

function createIceServerConfig(server) {
    let host = server.host;
    if (host.indexOf(':') >= 0) {
        host = `[${host}]`;
    }
    let uri = `${server.type}:${host}`;
    if (server.port) {
        uri += `:${server.port}`;
    }
    if (server.transport) {
        uri += `?transport=${server.transport}`;
    }
    if (server.type === 'turn' || server.type === 'turns') {
        return {
            credential: server.password,
            urls: [uri],
            username: server.username
        };
    }
    return { urls: [uri] };
}
class Mesh {
    constructor(client) {
        this.jingle = client.jingle;
        this.dispatch = client.dispatch;
        this.getState = client.getState;
        this.updateICEServers();
        this.jingle.config.peerConnectionConfig.sdpSemantics = 'plan-b';
    }
    updateICEServers() {
        this.jingle.resetICEServers();
        const config = getAPIConfig(this.getState());
        for (const server of config.iceServers) {
            this.jingle.addICEServer(createIceServerConfig(server));
        }
    }
    updateConnections() {
        if (!RTCPeerConnection) {
            return;
        }
        const state = this.getState();
        const videoPeersCount = countPeersWantingVideo(state);
        const calls = getJoinedCalls(state);
        const media = getMedia(state);
        const sharedMedia = getSharedMedia(state);
        const sharedVideoCount = sharedMedia.filter(m => m.kind === 'video').length;
        const activeCalls = new Set();
        for (const call of calls) {
            if (call.joined) {
                activeCalls.add(call.roomAddress);
            }
        }
        const videoResolutionTiers = getVideoResolutionTiers(state);
        let appliedTier = videoResolutionTiers[0];
        for (let i = 0; i < videoResolutionTiers.length; i++) {
            const tier = videoResolutionTiers[i];
            const nextTier = videoResolutionTiers[i + 1];
            if (tier[0] === videoPeersCount || !nextTier) {
                appliedTier = tier;
                break;
            }
            if (nextTier[0] > videoPeersCount) {
                appliedTier = tier;
                break;
            }
        }
        if (appliedTier) {
            const { width, height, frameRate } = appliedTier[1];
            this.dispatch(adjustVideoCaptureResolution(width, height, frameRate));
        }
        // The total bandwidth we want to send depends on the number of outgoing
        // video tracks. It is specified in kilobits per second.
        const maximumBitrate = 1800000 / (videoPeersCount * sharedVideoCount);
        // Dispose of any orphaned connections after leaving a call
        const allConnections = getConnections(state);
        for (const connId of Object.keys(allConnections)) {
            const conn = allConnections[connId];
            const sess = this.jingle.sessions[conn.id];
            if (sess && !activeCalls.has(conn.roomAddress)) {
                sess.end();
            }
        }
        for (const call of calls) {
            const peers = getPeersForCall(state, call.roomAddress);
            for (const peer of peers) {
                const needsVideo = new Set();
                const needsAudio = new Set();
                const wantsVideo = peer.requestingMedia === 'video';
                const wantsAudio = peer.requestingMedia === 'video' || peer.requestingMedia === 'audio';
                const peerSharedMedia = new Map();
                const overSharedSessions = new Set();
                const connections = getConnectionsForPeer(state, peer.address);
                for (const conn of connections) {
                    if (conn.sendingAudioMediaId) {
                        peerSharedMedia.set(conn.sendingAudioMediaId, 'audio');
                        if (!wantsAudio ||
                            !media[conn.sendingAudioMediaId] ||
                            !media[conn.sendingAudioMediaId].shared) {
                            overSharedSessions.add(conn.id);
                            if (conn.sendingVideoMediaId && wantsVideo) {
                                needsVideo.add(conn.sendingVideoMediaId);
                            }
                        }
                    }
                    if (conn.sendingVideoMediaId) {
                        const sess = this.jingle.sessions[conn.id];
                        if (sess) {
                            sess.setMaximumBitrate(maximumBitrate);
                        }
                        peerSharedMedia.set(conn.sendingVideoMediaId, 'video');
                        const video = media[conn.sendingVideoMediaId];
                        if ((!wantsVideo && !video.screenCapture) || !video || !video.shared) {
                            overSharedSessions.add(conn.id);
                            if (conn.sendingAudioMediaId && wantsAudio) {
                                needsAudio.add(conn.sendingAudioMediaId);
                            }
                        }
                    }
                }
                for (const track of sharedMedia) {
                    if (!peerSharedMedia.has(track.id)) {
                        if (track.kind === 'audio' && wantsAudio) {
                            needsAudio.add(track.id);
                        }
                        if (track.kind === 'video' && wantsVideo) {
                            needsVideo.add(track.id);
                        }
                        if (track.kind === 'video' && track.screenCapture && wantsAudio) {
                            needsVideo.add(track.id);
                        }
                    }
                }
                for (const sessionId of overSharedSessions) {
                    const session = this.jingle.sessions[sessionId];
                    if (session) {
                        session.end();
                    }
                }
                const pairedTracks = new Map();
                for (const id of [...needsAudio, ...needsVideo]) {
                    const track = media[id];
                    if (track) {
                        const pair = pairedTracks.get(track.stream.id) || {};
                        pair[track.kind] = track;
                        pairedTracks.set(track.stream.id, pair);
                    }
                }
                for (const pair of pairedTracks.values()) {
                    const session = this.jingle.createMediaSession(peer.address);
                    if (pair.audio) {
                        session.addTrack(pair.audio.track, pair.audio.stream);
                        this.dispatch(updateConnection(peer.address, session.sid, {
                            sendingAudioMediaId: pair.audio.id
                        }));
                    }
                    if (pair.video) {
                        session.addTrack(pair.video.track, pair.video.stream);
                        this.dispatch(updateConnection(peer.address, session.sid, {
                            sendingVideoMediaId: pair.video.id
                        }));
                    }
                    session.start({
                        offerToReceiveAudio: false,
                        offerToReceiveVideo: false
                    }, () => {
                        if (pair.video) {
                            session.setMaximumBitrate(maximumBitrate);
                        }
                        if (pair.audio && pair.audio.localDisabled) {
                            session.mute(session.role, 'audio');
                        }
                        if (pair.video && pair.video.localDisabled) {
                            session.mute(session.role, 'video');
                        }
                        if (pair.video && pair.video.screenCapture) {
                            session.send('description-info', {
                                contents: [
                                    {
                                        application: {
                                            applicationType: 'rtp',
                                            screenCaptures: [{ id: pair.video.id }]
                                        },
                                        name: 'video'
                                    }
                                ]
                            });
                        }
                    });
                }
            }
        }
    }
    plugin() {
        return () => {
            this.jingle.on('incoming', (session) => {
                const state = this.getState();
                const call = getCallForRoom(state, session.peerID.split('/')[0]);
                if (call && call.joined) {
                    session.accept();
                }
                else {
                    session.end();
                }
                session.onDescriptionInfo = (changes, cb) => {
                    const connections = getConnections(this.getState());
                    for (const content of changes.contents || []) {
                        if (content.application &&
                            content.application.screenCaptures &&
                            content.application.screenCaptures.length) {
                            this.dispatch(updateMedia(connections[session.sid].receivingVideoMediaId, {
                                screenCapture: true
                            }));
                        }
                    }
                    cb();
                };
            });
            this.jingle.on('terminated', (session, reason) => {
                this.dispatch(removeConnection(session.peerID, session.sid));
                if (reason.condition && reason.condition !== 'success' && reason.condition !== 'gone') {
                    console.error('Session terminated with error:', session.sid, reason);
                    this.dispatch(peerUpdated(session.peerID, {
                        sessionFailed: true
                    }));
                }
                // Probably terminated session because the peer is gone. Give the rest of
                // the system a chance to update before attempting to restart connections.
                setTimeout(() => {
                    this.updateConnections();
                }, 1000);
            });
            this.jingle.on('createdSession', (session) => {
                this.dispatch(addConnection(session.peerID, session.sid));
                session.on('peerTrackAdded', (_, track, stream) => {
                    // Track IDs can get reused across sessions, so we prefix with the session ID for
                    // remote tracks. Local tracks always have unique IDs.
                    const remoteTrackId = `${session.sid}#${track.id}`;
                    this.dispatch(addRemoteMedia(session.peerID.split('/')[0], session.peerID, remoteTrackId, track, stream, false));
                    if (track.kind === 'audio') {
                        this.dispatch(updateConnection(session.peerID, session.sid, {
                            receivingAudioMediaId: remoteTrackId
                        }));
                    }
                    if (track.kind === 'video') {
                        this.dispatch(updateConnection(session.peerID, session.sid, {
                            receivingVideoMediaId: remoteTrackId
                        }));
                    }
                });
                session.on('peerTrackRemoved', (_, track) => {
                    // Track IDs can get reused across sessions, so we prefix with the session ID for
                    // remote tracks. Local tracks always have unique IDs.
                    const remoteTrackId = `${session.sid}#${track.id}`;
                    this.dispatch(removeMedia(remoteTrackId));
                });
                session.on('connectionState', () => {
                    this.dispatch(updateConnection(session.peerID, session.sid, {
                        connectionState: session.connectionState,
                        restarting: session.restartingIce,
                        sessionState: session.state
                    }));
                    if (session.connectionState === 'connected') {
                        this.dispatch(peerUpdated(session.peerID, {
                            sessionFailed: false
                        }));
                    }
                    // Responder side doesn't restart ICE. Give initiator a chance, but do eventually end.
                    if ((session.role === 'responder' && session.connectionState === 'disconnected') ||
                        session.connectionState === 'interrupted') {
                        setTimeout(() => {
                            if (session.connectionState === 'disconnected' ||
                                session.connectionState === 'interrupted') {
                                session.end('failed-transport');
                            }
                        }, 5000);
                    }
                });
                session.on('sessionState', () => {
                    this.dispatch(updateConnection(session.peerID, session.sid, {
                        connectionState: session.connectionState,
                        restarting: session.restartingIce,
                        sessionState: session.state
                    }));
                });
            });
            this.jingle.on('mute', (session, info) => {
                const state = this.getState();
                const connections = getConnections(state);
                if (info.name === 'audio') {
                    this.dispatch(updateMedia(connections[session.sid].receivingAudioMediaId, {
                        remoteDisabled: true
                    }));
                }
                else if (info.name === 'video') {
                    this.dispatch(updateMedia(connections[session.sid].receivingVideoMediaId, {
                        remoteDisabled: true
                    }));
                }
                else {
                    throw new Error('Invalid mute property');
                }
            });
            this.jingle.on('unmute', (session, info) => {
                const state = this.getState();
                const connections = getConnections(state);
                if (info.name === 'audio') {
                    this.dispatch(updateMedia(connections[session.sid].receivingAudioMediaId, {
                        remoteDisabled: false
                    }));
                }
                else if (info.name === 'video') {
                    this.dispatch(updateMedia(connections[session.sid].receivingVideoMediaId, {
                        remoteDisabled: false
                    }));
                }
                else {
                    throw new Error('Invalid mute property');
                }
            });
        };
    }
    notifyPeers(media, action) {
        const state = this.getState();
        const connections = getConnections(state);
        Object.values(getClient(state).jingle.sessions).forEach((session) => {
            const conn = connections[session.sid];
            if (conn &&
                (conn.sendingAudioMediaId === media.id || conn.sendingVideoMediaId === media.id)) {
                session[action](session.role, media.kind);
            }
        });
    }
}

// --------------------------------------------------------------------
// Our custom XMPP extensions for MMUC + DataChannels
// --------------------------------------------------------------------
const MMUC_NS = 'http://andyet.net/xmlns/mmuc';
const TALKY_CORE_NS = 'https://talky.io/ns/core';
const TALKY_CORE_DATACHANNEL = 'https://talky.io/ns/datachannel';
function MMUC (client, stanza) {
    const types = stanza.utils;
    const TalkyCoreUser = stanza.define({
        element: 'user',
        fields: {
            customerData: {
                get() {
                    const data = types.getText(this.xml);
                    if (data) {
                        return JSON.parse(data);
                    }
                    return {};
                }
            },
            roomId: types.attribute('rid'),
            sessionId: types.attribute('sid'),
            type: types.attribute('type')
        },
        name: 'talkyUserInfo',
        namespace: TALKY_CORE_NS
    });
    const MediaStream = stanza.define({
        element: 'mediastream',
        fields: {
            audio: types.attribute('audio'),
            msid: types.attribute('msid'),
            video: types.attribute('video')
        },
        name: '_mediaStream',
        namespace: MMUC_NS
    });
    const ScreenCapture = stanza.define({
        element: 'screen',
        fields: {
            id: types.attribute('id')
        },
        name: '_screenCapture',
        namespace: TALKY_CORE_NS
    });
    const DataChannel = stanza.define({
        element: 'description',
        fields: {
            applicationType: { value: 'datachannel' }
        },
        name: '_datachannel',
        namespace: TALKY_CORE_DATACHANNEL,
        tags: ['jingle-application']
    });
    const Conference = stanza.define({
        element: 'conf',
        fields: {
            bridged: types.boolAttribute('bridged'),
            lastN: types.numberAttribute('last-n'),
            media: types.attribute('media')
        },
        name: 'mmuc',
        namespace: MMUC_NS
    });
    const Status = stanza.define({
        element: 'status',
        fields: {
            active: types.boolAttribute('active'),
            media: types.attribute('media'),
            mode: types.attribute('mode'),
            ready: types.boolAttribute('ready'),
            recordable: types.boolAttribute('recordable'),
            stamp: types.dateAttribute('stamp')
        },
        name: 'mmucStatus',
        namespace: MMUC_NS
    });
    const RecordingStatus = stanza.define({
        element: 'recording',
        fields: {
            active: types.boolAttribute('active'),
            stamp: types.dateAttribute('stamp'),
            state: types.attribute('state'),
            uri: types.attribute('uri')
        },
        name: 'recording',
        namespace: MMUC_NS
    });
    const ParticipantState = stanza.define({
        element: 'state',
        fields: {
            speaking: types.boolAttribute('speaking')
        },
        name: 'mmuc',
        namespace: MMUC_NS
    });
    const CallControl = stanza.define({
        element: 'query',
        fields: {
            endMedia: types.boolSub(MMUC_NS, 'end-media'),
            startRecord: types.boolSub(MMUC_NS, 'start-recording')
        },
        name: 'mmuc',
        namespace: MMUC_NS
    });
    const StartCall = stanza.define({
        element: 'start-media',
        fields: {
            media: types.attribute('media')
        },
        name: 'startMedia',
        namespace: MMUC_NS
    });
    const EndRecord = stanza.define({
        element: 'end-recording',
        fields: {
            uri: types.attribute('uri')
        },
        name: 'endRecord',
        namespace: MMUC_NS
    });
    stanza.extend(Status, RecordingStatus);
    stanza.extend(CallControl, StartCall);
    stanza.extend(CallControl, EndRecord);
    stanza.withPresence((Presence) => {
        stanza.extend(Presence, Conference);
        stanza.extend(Presence, MediaStream, 'mediaStreams');
        stanza.extend(Presence, TalkyCoreUser);
    });
    stanza.withMessage((Message) => {
        stanza.extend(Message, Status);
        stanza.extend(Message, ParticipantState);
    });
    stanza.withIQ((IQ) => {
        stanza.extend(IQ, CallControl);
    });
    stanza.withDefinition('content', 'urn:xmpp:jingle:1', (Content) => {
        stanza.extend(Content, DataChannel);
    });
    stanza.withDefinition('description', 'urn:xmpp:jingle:apps:rtp:1', (RTP) => {
        stanza.extend(RTP, ScreenCapture, 'screenCaptures');
    });
    stanza.withDefinition('jingle', 'urn:xmpp:jingle:1', (Jingle) => {
        stanza.extend(Jingle, MediaStream, 'mediaStreams');
    });
}

class SignalingClient {
    constructor(dispatch, getState, opts) {
        this.logToConsole = localStorage.logxmpp || false;
        this.terminating = false;
        this.dispatch = dispatch;
        this.getState = getState;
        this.rttBuffers = new Map();
        this.xmpp = createClient(Object.assign({ transport: 'websocket' }, opts));
        this.xmpp.useStreamManagement = false;
        this.xmpp.sm.allowResume = false;
        this.jingle = this.xmpp.jingle;
        this.xmpp.use(MMUC);
        this.mesh = new Mesh(this);
        this.xmpp.use(this.mesh.plugin());
        this.xmpp.on('raw:*', (event, data) => {
            if (this.logToConsole) {
                console.log(event, data);
            }
        });
        this.xmpp.on('session:started', () => {
            this.xmpp.sendPresence();
            this.xmpp.enableKeepAlive({
                interval: 90
            });
            this.dispatch(connectionStateChanged('connected'));
        });
        this.xmpp.on('disconnected', () => {
            if (this.terminating) {
                return;
            }
            this.dispatch(connectionStateChanged('disconnected'));
            setTimeout(() => {
                const state = this.getState();
                const configUrl = getConfigURL(state);
                const userData = getUserToken(state);
                this.dispatch(connect(configUrl, userData));
            }, 1000 + Math.random() * 2000);
        });
        this.xmpp.on('muc:join', (pres) => __awaiter(this, void 0, void 0, function* () {
            const roomAddress = pres.from.bare;
            const state = this.getState();
            let room = getRoomByAddress(state, roomAddress);
            if (!room) {
                return;
            }
            yield this.checkLockStatus(roomAddress, room.providedPassword);
            this.dispatch(joinRoomSuccess(roomAddress, pres.from.full, pres.talkyUserInfo.roomId, pres.muc.role, pres.muc.affiliation));
            room = getRoomByAddress(state, roomAddress);
            if (room && room.autoJoinCall) {
                this.dispatch(joinCall(roomAddress, getDesiredMediaTypes(state, roomAddress)));
            }
        }));
        this.xmpp.on('muc:failed', (pres) => {
            const roomAddress = pres.from.bare;
            const room = getRoomByAddress(this.getState(), roomAddress);
            if (room && room.providedPassword && !room.passwordRequired) {
                this.joinRoom(roomAddress, undefined, room.autoJoinCall);
            }
            else {
                this.dispatch(joinRoomFailed(roomAddress, pres.error.condition === 'not-authorized'));
            }
        });
        this.xmpp.on('muc:error', (pres) => {
            this.dispatch(joinRoomFailed(pres.from.bare, pres.error.condition === 'not-authorized'));
        });
        this.xmpp.on('muc:available', (pres) => {
            const roomAddress = pres.from.bare;
            const peerAddress = pres.from.full;
            const state = this.getState();
            const room = getRoomByAddress(state, roomAddress);
            if (!room) {
                return;
            }
            if (pres.muc.codes && pres.muc.codes.indexOf('110') >= 0) {
                this.dispatch(selfUpdated(roomAddress, peerAddress, room.id, pres.muc.role, pres.muc.affiliation));
                return;
            }
            if (!this.rttBuffers.has(peerAddress)) {
                const buffer = new DisplayBuffer(({ text }) => {
                    this.dispatch(peerUpdated(peerAddress, {
                        rtt: text
                    }));
                });
                this.rttBuffers.set(peerAddress, buffer);
            }
            const customerData = pres.talkyUserInfo.customerData || {};
            this.dispatch(peerOnline(roomAddress, peerAddress, {
                affiliation: pres.muc.affiliation,
                customerData,
                displayName: customerData.displayName || pres.nick,
                id: pres.talkyUserInfo.sessionId,
                joinedCall: !!pres.mmuc,
                requestingMedia: (pres.mmuc || {}).media,
                role: pres.muc.role
            }));
        });
        this.xmpp.on('muc:unavailable', (pres) => {
            if (pres.muc.codes && pres.muc.codes.indexOf('110') >= 0) {
                this.dispatch(leaveRoom(pres.from.bare));
                return;
            }
            this.rttBuffers.delete(pres.from.full);
            this.dispatch(peerOffline(pres.from.bare, pres.from.full));
        });
        this.xmpp.on('muc:destroyed', (pres) => {
            this.dispatch(leaveRoom(pres.from.bare));
        });
        this.xmpp.on('chat:state', (msg) => {
            this.dispatch(peerUpdated(msg.from.full, {
                chatState: msg.chatState
            }));
        });
        this.xmpp.on('attention', (msg) => {
            this.dispatch(peerUpdated(msg.from.full, {
                requestingAttention: true
            }));
            setTimeout(() => {
                this.dispatch(peerUpdated(msg.from.full, {
                    requestingAttention: false
                }));
            }, 5000);
        });
        this.xmpp.on('message', (msg) => {
            if (msg.type !== 'groupchat') {
                return;
            }
            if (msg.rtt) {
                const buffer = this.rttBuffers.get(msg.from.full);
                if (buffer) {
                    buffer.process(msg.rtt);
                }
            }
            if (msg.body) {
                const buffer = this.rttBuffers.get(msg.from.full);
                if (buffer) {
                    buffer.commit();
                }
                this.dispatch(receiveChat(msg.from.bare, msg.from.full, {
                    body: msg.body,
                    displayName: msg.nick,
                    id: msg.id,
                    replace: msg.replace,
                    time: msg.delay ? msg.delay.stamp : new Date()
                }));
            }
        });
        this.xmpp.on('message', (msg) => this.processMessage(msg));
    }
    connect() {
        this.xmpp.connect();
    }
    disconnect() {
        this.terminating = true;
        this.dispatch(connectionStateChanged('disconnected'));
        this.xmpp.disconnect();
    }
    joinRoom(roomAddress, password, autoJoinCall) {
        const state = this.getState();
        const config = getAPIConfig(state);
        const displayName = getUserDisplayName(state);
        const opts = {
            joinMuc: {
                password
            },
            nick: displayName
        };
        this.xmpp.joinRoom(roomAddress, config.id, opts);
        if (autoJoinCall !== false) {
            this.dispatch(joinCall(roomAddress, getDesiredMediaTypes(state, roomAddress)));
        }
    }
    destroyRoom(roomAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.xmpp.destroyRoom(roomAddress);
        });
    }
    sendRoomPresence(roomAddress, opts = {}) {
        const state = this.getState();
        const displayName = getUserDisplayName(state);
        const room = getRoomByAddress(state, roomAddress);
        const call = getCallForRoom(state, roomAddress);
        const media = getDesiredMediaTypes(state, roomAddress);
        if (!room || !room.joined) {
            return;
        }
        this.xmpp.sendPresence(Object.assign({ mmuc: call && call.joined
                ? {
                    media
                }
                : undefined, nick: displayName || true, to: roomAddress }, opts));
    }
    sendAllRoomsPresence(opts = {}) {
        const state = this.getState();
        const rooms = Object.keys(getRooms(state));
        for (const roomAddress of rooms) {
            this.sendRoomPresence(roomAddress, opts);
        }
    }
    sendAllCallsSpeakingUpdate(speaking) {
        const state = this.getState();
        const calls = getJoinedCalls(state);
        for (const call of calls) {
            this.xmpp.sendMessage({
                mmuc: {
                    speaking
                },
                to: call.roomAddress,
                type: 'groupchat'
            });
        }
    }
    lockRoom(roomAddress, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.getState();
            const room = getRoomByAddress(state, roomAddress);
            if (!room || !room.joined || room.selfAffiliation !== 'owner') {
                return;
            }
            try {
                yield this.xmpp.configureRoom(roomAddress, {
                    fields: [
                        {
                            name: 'FORM_TYPE',
                            value: 'http://jabber.org/protocol/muc#roomconfig'
                        },
                        {
                            name: 'muc#roomconfig_whois',
                            type: 'text-single',
                            value: 'moderators'
                        },
                        {
                            name: 'muc#roomconfig_roomsecret',
                            type: 'text-single',
                            value: password
                        },
                        {
                            name: 'muc#roomconfig_passwordprotectedroom',
                            type: 'boolean',
                            value: '1'
                        }
                    ]
                });
                this.dispatch(roomLocked(roomAddress, password));
            }
            catch (err) {
                console.error(err);
            }
        });
    }
    unlockRoom(roomAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.getState();
            const room = getRoomByAddress(state, roomAddress);
            if (!room || !room.joined || room.selfAffiliation !== 'owner') {
                return;
            }
            try {
                yield this.xmpp.configureRoom(roomAddress, {
                    fields: [
                        {
                            name: 'FORM_TYPE',
                            value: 'http://jabber.org/protocol/muc#roomconfig'
                        },
                        {
                            name: 'muc#roomconfig_whois',
                            type: 'text-single',
                            value: 'moderators'
                        },
                        {
                            name: 'muc#roomconfig_roomsecret',
                            type: 'text-single',
                            value: ''
                        },
                        {
                            name: 'muc#roomconfig_passwordprotectedroom',
                            type: 'boolean',
                            value: '1'
                        }
                    ]
                });
                this.dispatch(roomUnlocked(roomAddress));
            }
            catch (err) {
                console.error(err);
            }
        });
    }
    fetchRoomConfig(roomAddress, initial = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = {};
            const state = this.getState();
            const room = getRoomByAddress(state, roomAddress);
            if (!initial && (!room || !room.joined)) {
                throw new Error('Room not joined');
            }
            const res = yield this.xmpp.getRoomConfig(roomAddress);
            const form = res.mucOwner.form;
            for (const field of form.fields) {
                if (field.name === 'muc#roomconfig_roomsecret') {
                    if (field.value) {
                        config.password = field.value;
                    }
                    else {
                        config.password = undefined;
                    }
                }
            }
            return config;
        });
    }
    checkLockStatus(roomAddress, providedPassword, forceInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const room = getRoomByAddress(this.getState(), roomAddress);
            if (!room) {
                return;
            }
            if (room.selfAffiliation === 'owner' && !forceInfo) {
                try {
                    const config = yield this.fetchRoomConfig(roomAddress, true);
                    if (config.password) {
                        this.dispatch(roomLocked(roomAddress, config.password));
                    }
                    else if (providedPassword) {
                        this.dispatch(lockRoom(roomAddress, providedPassword));
                    }
                    else {
                        this.dispatch(roomUnlocked(roomAddress));
                    }
                }
                catch (err) {
                    console.error(err);
                    return this.checkLockStatus(roomAddress, providedPassword, true);
                }
            }
            else {
                try {
                    const res = yield this.xmpp.getDiscoInfo(roomAddress);
                    if (res.discoInfo.features.indexOf('muc_passwordprotected') >= 0) {
                        this.dispatch(roomLocked(roomAddress));
                    }
                    else {
                        this.dispatch(roomUnlocked(roomAddress));
                    }
                }
                catch (err) {
                    console.error(err);
                }
            }
        });
    }
    processMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const roomAddress = msg.from.bare;
            const room = getRoomByAddress(this.getState(), roomAddress);
            if (msg.type === 'groupchat' && msg.mmuc) {
                if (room && room.selfAddress !== msg.from.full && msg.mmuc) {
                    this.dispatch(peerUpdated(msg.from.full, {
                        speaking: msg.mmuc.speaking || false
                    }));
                }
            }
            if (msg.muc && msg.muc.codes && msg.muc.codes.indexOf('104') >= 0) {
                yield this.checkLockStatus(roomAddress);
            }
        });
    }
}

let REPORTING_INTERVAL;
function sleep(timeout, throwError = false) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            setTimeout(() => (throwError ? reject() : resolve()), timeout);
        });
    });
}
/**
 * Fetch service configuration from the API.
 *
 * @private
 *
 * @param configUrl string
 * @param maxTries number
 * @param delay number
 * @param timeout number
 */
function fetchConfig(configUrl, userData, maxTries = 10, delay = 1000, timeout = 10000) {
    return __awaiter(this, void 0, void 0, function* () {
        let attemptCount = 0;
        let error;
        while (attemptCount <= maxTries) {
            try {
                const data = yield Promise.race([
                    fetch(configUrl, {
                        body: JSON.stringify({
                            clientVersion: SDK_VERSION,
                            token: userData
                        }),
                        headers: {
                            Accept: 'application/json',
                            'Content-Type': 'application/json'
                        },
                        method: 'POST'
                    }),
                    sleep(timeout, true)
                ]);
                if (!data.ok) {
                    throw new Error('SimpleWebRTC configuration request failed: ' + data.status);
                }
                const config = yield data.json();
                if (userData && !config.customerData) {
                    console.error('ESWRTC_003. View more information at https://docs.simplewebrtc.com');
                }
                return config;
            }
            catch (err) {
                error = err;
                attemptCount += 1;
                yield sleep(delay);
            }
        }
        if (error) {
            console.error('ESWRTC_001. View more information at https://docs.simplewebrtc.com');
            throw error;
        }
    });
}
// ====================================================================
/**
 * @description
 * Everything starts here.
 *
 * Connect to the API service.
 *
 * The `configUrl` value is provided to you as part of your SimpleWebRTC subscription.
 *
 * The `userData` value is a signed JWT, signed using the API secret provided to you as part of your SimpleWebRTC subscription.
 *
 * The data encoded in the `userData` JWT will be sent to the peers in any rooms joined. Likewise, `userData` from other peers will be made available in the `customerData` field of their peer objects. Uses for the `userData` JWT include providing an avatar URL or a custom username.
 *
 * The `userData` is _not_ used by SimpleWebRTC itself beyond making it available to you.
 *
 * @public
 *
 * @param configUrl The URL used to fetch the service configuration
 * @param userData A signed JWT containing the customer data you wish to have propragated to other peers
 */
function connect(configUrl, userData) {
    return (dispatch, getState) => __awaiter(this, void 0, void 0, function* () {
        let config;
        dispatch(connectionStateChanged('connecting'));
        try {
            config = yield fetchConfig(configUrl, userData);
            dispatch(receivedConfig(configUrl, config, userData));
        }
        catch (err) {
            dispatch(receivedConfigError());
            dispatch(connectionStateChanged('failed'));
            return;
        }
        const signalingClient = new SignalingClient(dispatch, getState, {
            jid: config.userId,
            password: config.credential,
            resource: config.id,
            wsURL: config.signalingUrl
        });
        dispatch({
            payload: signalingClient,
            type: SIGNALING_CLIENT
        });
        signalingClient.connect();
    });
}
/**
 * @description
 * Leaves all rooms and disconnects from the SimpleWebRTC service.
 *
 * @public
 */
function disconnect() {
    return (dispatch, getState) => {
        const signalingClient = getClient(getState());
        if (signalingClient) {
            signalingClient.disconnect();
        }
        dispatch({
            type: SIGNALING_CLIENT_SHUTDOWN
        });
    };
}
/**
 * Service configuration fetched from the API.
 *
 * @private
 *
 * @param config APIConfig
 */
function receivedConfig(configUrl, config, userData) {
    return {
        payload: {
            config,
            configUrl,
            token: userData
        },
        type: RECEIVED_CONFIG
    };
}
function receivedConfigError(err) {
    return {
        type: RECEIVED_CONFIG_ERROR
    };
}
/**
 * Queue a telemetry event to be sent in the next reporting batch.
 *
 * @private
 */
function queueTelemetry(eventType, { roomId, peerId, data }) {
    return {
        payload: {
            data: JSON.stringify(data),
            peerId,
            roomId
        },
        type: QUEUE_TELEMETRY
    };
}
/**
 * Send queued telemetry events as a single batch.
 *
 * @private
 */
function sendQueuedTelemetry() {
    return (dispatch, getState) => {
        const state = getState();
        const config = getAPIConfig(state);
        const telemetryUrl = config.telemetryUrl;
        const queuedTelemetry = getQueuedTelemetry(state);
        const batchSize = Math.min(queuedTelemetry.length, 10);
        if (batchSize === 0) {
            return;
        }
        const batch = queuedTelemetry.slice(0, batchSize);
        if (!telemetryUrl) {
            return;
        }
        const payload = {
            body: JSON.stringify({
                batch
            }),
            headers: {
                authorization: `Bearer ${config.credential}`
            },
            method: 'POST'
        };
        fetch(telemetryUrl, payload).then(() => {
            dispatch(telemetrySucess(batchSize));
        });
    };
}
/**
 * Report the number of successfully posted telemetry events.
 *
 * @private
 *
 * @param batchSize number
 */
function telemetrySucess(batchSize) {
    return {
        payload: batchSize,
        type: TELEMETRY_SUCCESS
    };
}
/**
 * Start the telemetry reporting interval timer.
 *
 * @private
 *
 * @param interval number
 */
function enableTelemetry(interval = 5000) {
    return dispatch => {
        disableTelemetry();
        REPORTING_INTERVAL = setInterval(() => {
            dispatch(sendQueuedTelemetry());
        }, interval);
    };
}
/**
 * Clear the telemetry reporting interval timer.
 *
 * @private
 */
function disableTelemetry() {
    clearInterval(REPORTING_INTERVAL);
}
/**
 * The connection state of the signaling client changed.
 *
 * @private
 *
 * @param connectionState string
 */
function connectionStateChanged(connectionState) {
    return {
        payload: connectionState,
        type: CONNECTION_STATE_CHANGE
    };
}

const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
const AudioContext = window.AudioContext || window.webkitAudioContext;

// ====================================================================
/**
 * Add a local media track.
 *
 * @private
 *
 * @param track
 * @param stream
 * @param replaces
 */
function addLocalMedia(media) {
    return (dispatch, getState) => {
        let newReplaces = media.replaces;
        if (media.replaces) {
            const state = getState();
            const prevMedia = getMediaTrack(state, media.replaces);
            if (prevMedia) {
                if (!prevMedia.shared) {
                    dispatch(removeMedia(prevMedia.id));
                    newReplaces = prevMedia.replaces;
                }
            }
        }
        media.track.onmute = () => {
            dispatch(updateMedia(media.id, {
                externalDisabled: true
            }));
        };
        media.track.onunmute = () => {
            dispatch(updateMedia(media.id, {
                externalDisabled: false
            }));
        };
        dispatch({
            payload: Object.assign({}, media, { replaces: newReplaces }),
            type: ADD_MEDIA
        });
    };
}
/**
 * @description
 * Adds a local audio track to the set of managed media.
 *
 * **NOTE:** Adding a local audio track does not immediately share the audio to peers. Use `shareLocalMedia()` with the track ID to do so after adding.
 *
 * @public
 *
 * @param track Local audio track
 * @param stream Stream containing the audio track
 * @param replaces
 */
function addLocalAudio(track, stream, replaces) {
    if (track.kind !== 'audio') {
        throw new Error('Incorrect media type. Expected audio, got: ' + track.kind);
    }
    return (dispatch, getState) => {
        let hark;
        let utilityStream;
        {
            track.onended = () => {
                dispatch(stopSharingLocalMedia(track.id));
                dispatch(removeMedia(track.id));
            };
        }
        dispatch(addLocalMedia({
            createdAt: Date.now(),
            externalDisabled: track.muted,
            hark,
            id: track.id,
            inputDetected: false,
            inputLost: Date.now(),
            kind: 'audio',
            localDisabled: !track.enabled,
            remoteDisabled: false,
            renderMirrored: false,
            replaces,
            screenCapture: false,
            shared: false,
            source: 'local',
            speaking: false,
            stream,
            track,
            utilityStream,
            volume: -Infinity
        }));
    };
}
/**
 * @description
 * Adds a local video track to the set of managed media.
 *
 * **NOTE:** Adding a local video track does not immediately share the video to peers. Use `shareLocalMedia()` with the track ID to do so after adding.
 *
 * @public
 *
 * @param track Local video track
 * @param stream Stream containing the video track
 * @param replaces
 */
function addLocalVideo(track, stream, mirror = true, replaces) {
    if (track.kind !== 'video') {
        throw new Error('Incorrect media type. Expected video, got: ' + track.kind);
    }
    return (dispatch, getState) => {
        track.onended = () => {
            dispatch(stopSharingLocalMedia(track.id));
            dispatch(removeMedia(track.id));
        };
        if (replaces) {
            // React-Native
            // Remove old video before adding the new one to prevent a mirroring
            // flash when going from 'user' to 'environment' and vice versa
            dispatch(removeMedia(replaces));
        }
        dispatch(addLocalMedia({
            createdAt: Date.now(),
            externalDisabled: track.muted,
            id: track.id,
            kind: 'video',
            localDisabled: !track.enabled,
            remoteDisabled: false,
            renderMirrored: mirror,
            replaces,
            screenCapture: false,
            shared: false,
            source: 'local',
            speaking: false,
            stream,
            track,
            volume: -Infinity
        }));
    };
}
/**
 * @description
 * Adds a local screenshare video track to the set of managed media.
 *
 * This action is similar to `addLocalVideo()`, but marks the video as a screen so it does not render mirrored like a user facing camera video.
 *
 * **NOTE:** Adding a local screenshare video track does not immediately share the video to peers. Use `shareLocalMedia()` with the track ID to do so after adding.
 *
 * @public
 *
 * @param track Local screenshare video track
 * @param stream Stream containing the video track
 * @param replaces
 */
function addLocalScreen(track, stream, replaces) {
    if (track.kind !== 'video') {
        throw new Error('Incorrect media type. Expected video, got: ' + track.kind);
    }
    return (dispatch, getState) => {
        track.onended = () => {
            dispatch(stopSharingLocalMedia(track.id));
            dispatch(removeMedia(track.id));
        };
        // Mark the track as detail content to encourage the browser to
        // prioritize image quality over frame rate.
        if ('contentHint' in track) {
            track.contentHint = 'detail';
        }
        dispatch(addLocalMedia({
            createdAt: Date.now(),
            externalDisabled: track.muted,
            id: track.id,
            kind: 'video',
            localDisabled: !track.enabled,
            remoteDisabled: false,
            renderMirrored: false,
            replaces,
            screenCapture: true,
            shared: false,
            source: 'local',
            speaking: false,
            stream,
            track,
            volume: -Infinity
        }));
    };
}
/**
 * Add a remote media track.
 *
 * @private
 *
 * @param track MediaStreamTrack
 * @param stream MediaStream
 * @param screen boolean
 */
function addRemoteMedia(roomAddress, peerAddress, id, track, stream, screen) {
    return (dispatch, getState) => {
        const state = getState();
        const owner = getPeerByAddress(state, peerAddress);
        track.onended = () => {
            dispatch(removeMedia(id));
        };
        const media = {
            createdAt: Date.now(),
            externalDisabled: track.muted,
            id,
            kind: track.kind,
            localDisabled: owner ? owner.muted : false,
            owner: peerAddress,
            remoteDisabled: false,
            renderMirrored: false,
            roomAddress,
            screenCapture: track.kind === 'video' && screen,
            source: 'remote',
            speaking: false,
            stream,
            track,
            volume: -Infinity
        };
        dispatch({
            payload: media,
            type: ADD_MEDIA
        });
    };
}
/**
 * @description
 * Remove media.
 *
 * @public
 *
 * @param id Media track ID
 * @param endMedia Whether to end the media track
 */
function removeMedia(id, endMedia = true) {
    return (dispatch, getState) => {
        const media = getMediaTrack(getState(), id);
        if (!media) {
            return;
        }
        if (media.shared) {
            dispatch(stopSharingLocalMedia(id));
        }
        dispatch({
            payload: { id },
            type: REMOVE_MEDIA
        });
        const client = getClient(getState());
        if (client) {
            client.mesh.updateConnections();
        }
        if (endMedia) {
            if (media.track) {
                media.track.stop();
            }
            if (media.utilityStream) {
                for (const track of media.utilityStream.getTracks()) {
                    track.stop();
                }
            }
        }
    };
}
/**
 * Update a media track.
 *
 * @private
 *
 * @param id string
 * @param updated Partial<Media>
 */
function updateMedia(id, updated) {
    return (dispatch, getState) => {
        const prevState = getState();
        const client = getClient(prevState);
        const wasSpeaking = userIsSpeaking(prevState);
        dispatch({
            payload: {
                id,
                updated
            },
            type: MEDIA_UPDATED
        });
        const newState = getState();
        const nowSpeaking = userIsSpeaking(newState);
        if (client) {
            if (wasSpeaking !== nowSpeaking) {
                client.sendAllCallsSpeakingUpdate(nowSpeaking);
            }
            if (updated.shared !== undefined) {
                client.mesh.updateConnections();
            }
        }
        const oldMedia = getMediaTrack(prevState, id);
        const newMedia = getMediaTrack(newState, id);
        if (newMedia) {
            newMedia.track.enabled = !newMedia.localDisabled;
            if (oldMedia &&
                newMedia.source === 'local' &&
                newMedia.localDisabled !== oldMedia.localDisabled &&
                client) {
                client.mesh.notifyPeers(newMedia, newMedia.localDisabled === true ? 'mute' : 'unmute');
            }
            if (newMedia.source === 'remote' && newMedia.owner) {
                const peer = getPeerByAddress(newState, newMedia.owner);
                if (peer && peer.muted && !newMedia.localDisabled) {
                    dispatch({
                        payload: {
                            peerAddress: newMedia.owner,
                            updated: {
                                muted: false
                            }
                        },
                        type: PEER_UPDATED
                    });
                }
            }
        }
    };
}
/**
 * @description
 * Enable local playback of local or remote media.
 *
 * @public
 *
 * @param id Media track ID
 */
function enableMedia(id) {
    return updateMedia(id, {
        localDisabled: false
    });
}
/**
 * @description
 * Disable local playback of local or remote media.
 *
 * If the media has already been shared, it will continue to be shared, but will be silent or show a black frame.
 *
 * @public
 *
 * @param id A local media track ID
 */
function disableMedia(id) {
    return updateMedia(id, {
        localDisabled: true
    });
}
/**
 * @description
 * Share a local media track with interested peers.
 *
 * @public
 *
 * @param id The ID of the media track to start sharing
 */
function shareLocalMedia(id) {
    return (dispatch, getState) => {
        const state = getState();
        const media = getMediaTrack(state, id);
        if (!media) {
            return;
        }
        if (media.replaces) {
            dispatch(removeMedia(media.replaces));
        }
        dispatch(updateMedia(id, {
            replaces: undefined,
            shared: true
        }));
    };
}
/**
 * @description
 * Stop sending a media track to peers, but the media track will still exist and be tracked so that it can be re-shared later. Use `removeMedia()` to fully stop and remove a track.
 *
 * @public
 *
 * @param id The ID of the media track to stop sharing
 */
function stopSharingLocalMedia(id) {
    return (dispatch, getState) => {
        const state = getState();
        const potentialReplacements = getLocalMedia(state).filter(m => m.replaces === id);
        dispatch(updateMedia(id, {
            shared: false
        }));
        if (potentialReplacements.length) {
            dispatch(removeMedia(id));
        }
    };
}
/**
 * @description
 * Adjust the capture resolution for local videos.
 *
 * Screen captures are _not_ affected.
 *
 * The values provided should be the _ideal_ values. The browser will attempt to adjust capture parameters to match as closely as possible, but in some cases may not exactly match what was requested.
 *
 * @public
 *
 * @param width The new, ideal, width for the video
 * @param height The new, ideal, height for the video
 * @param frameRate The new, ideal, frame rate for the video
 */
function adjustVideoCaptureResolution(width, height, frameRate = 30) {
    return (dispatch, getState) => {
        {
            return;
        }
        const state = getState();
        const localMedia = getLocalMedia(state, 'video');
        const supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
        const newConstraints = {};
        let enabledConstraint = false;
        if (supportedConstraints.frameRate) {
            newConstraints.frameRate = frameRate;
            enabledConstraint = true;
        }
        if (supportedConstraints.height) {
            newConstraints.height = { ideal: height };
            enabledConstraint = true;
        }
        if (supportedConstraints.width) {
            newConstraints.width = { ideal: width };
            enabledConstraint = true;
        }
        if (!enabledConstraint) {
            return;
        }
        for (const video of localMedia) {
            if (video.screenCapture) {
                continue;
            }
            video.track.applyConstraints(newConstraints).catch(err => {
                console.error('Could not adjust video capture resolution:', err.message);
            });
        }
    };
}
/**
 * @description
 * Set the full table of video resolution tiers to use, based on the number of peers.
 *
 * Each tier looks like: [peerCount, { width, height, frameRate }]
 *
 * The tier with a peerCount matching the number of peers requesting video will be used.
 * (Or the tier with the smaller peerCount if the number of peers falls between tiers.)
 *
 * Screen captures are _not_ affected by video resolution tiers.
 *
 * The resolution values provided should be the _ideal_ values. The browser will attempt to adjust capture parameters to match as closely as possible, but in some cases may not exactly match what was requested.
 *
 * @public
 *
 * @param tiers Array of ideal video resolution tiers based on peer count
 */
function setVideoResolutionTiers(tiers) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                videoResolutionTiers: tiers
            },
            type: SET_VIDEO_RESOLUTION_TIERS
        });
        const client = getClient(getState());
        if (client) {
            client.mesh.updateConnections();
        }
    };
}
/**
 * @description
 * Mute all audio for a given peer.
 *
 * @public
 *
 * @param peerAddress The address of the peer to mute
 */
function mutePeer(peerAddress) {
    return (dispatch, getState) => {
        const state = getState();
        const media = getMediaForPeer(state, peerAddress, 'audio');
        for (const audio of media) {
            dispatch(disableMedia(audio.id));
        }
        dispatch({
            payload: {
                peerAddress,
                updated: {
                    muted: true
                }
            },
            type: PEER_UPDATED
        });
    };
}
/**
 * @description
 * Unmute all audio for a given peer.
 *
 * @public
 *
 * @param peerAddress The address of the peer to unmute
 */
function unmutePeer(peerAddress) {
    return (dispatch, getState) => {
        const state = getState();
        const media = getMediaForPeer(state, peerAddress, 'audio');
        for (const audio of media) {
            dispatch(enableMedia(audio.id));
        }
        dispatch({
            payload: {
                peerAddress,
                updated: {
                    muted: false
                }
            },
            type: PEER_UPDATED
        });
    };
}
/**
 * @description
 * Disable all captured audio for the user.
 *
 * @public
 */
function muteSelf() {
    return (dispatch, getState) => {
        const state = getState();
        const media = getLocalMedia(state, 'audio');
        for (const audio of media) {
            dispatch(disableMedia(audio.id));
        }
    };
}
/**
 * @description
 * Enable all captured audio for the user.
 *
 * @public
 */
function unmuteSelf() {
    return (dispatch, getState) => {
        const state = getState();
        const media = getLocalMedia(state, 'audio');
        for (const audio of media) {
            dispatch(enableMedia(audio.id));
        }
    };
}
/**
 * @description
 * Disable all captured video for the user.
 *
 * @public
 */
function pauseSelfVideo() {
    return (dispatch, getState) => {
        const state = getState();
        const media = getLocalMedia(state, 'video');
        for (const video of media) {
            dispatch(disableMedia(video.id));
        }
    };
}
/**
 * @description
 * Enable all captured video for the user.
 *
 * @public
 */
function resumeSelfVideo() {
    return (dispatch, getState) => {
        const state = getState();
        const media = getLocalMedia(state, 'video');
        for (const video of media) {
            dispatch(enableMedia(video.id));
        }
    };
}
/**
 * @description
 * Remove all local media of a given kind.
 *
 * @public
 *
 * @param kind 'audio' | 'video' | undefined
 */
function removeAllMedia(kind) {
    return (dispatch, getState) => {
        const state = getState();
        const localMedia = getLocalMedia(state, kind);
        for (const media of localMedia) {
            dispatch(removeMedia(media.id));
        }
    };
}

// ====================================================================
function startCall() {
    return;
}
function endCall() {
    return;
}
/**
 * @description
 * Once joined to a room, using the `joinCall()` action will trigger joining the active call.
 *
 * The `desiredMedia` parameter can be used to control what media is received from peers. By default, it will use the type used in the global `setDesiredMedia()` action.
 *
 * **NOTE:** While the `desiredMedia` parameter controls what is _received_, what is _sent_ is determined by which tracks you have marked as shared via `shareLocalMedia()`. It is entirely possible to send audio and video while only receiving audio.
 *
 * @public
 *
 * @param roomAddress The address of a joined room
 * @param desiredMedia The media type to request from peers
 */
function joinCall(roomAddress, desiredMedia) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                desiredMedia,
                roomAddress
            },
            type: JOIN_CALL
        });
        const state = getState();
        const client = getClient(state);
        if (client) {
            client.sendRoomPresence(roomAddress);
            client.mesh.updateConnections();
        }
    };
}
/**
 * @description
 * @public
 *
 * @param roomAddress The address of the room hosting the call
 */
function leaveCall(roomAddress) {
    return (dispatch, getState) => {
        const state = getState();
        const originalCalls = getJoinedCalls(state);
        dispatch({
            payload: {
                roomAddress
            },
            type: LEAVE_CALL
        });
        const updatedState = getState();
        const remainingCalls = getJoinedCalls(updatedState);
        const client = getClient(state);
        if (client) {
            client.sendRoomPresence(roomAddress);
            client.mesh.updateConnections();
            const speaking = userIsSpeaking(state);
            if (speaking) {
                client.sendAllCallsSpeakingUpdate(true);
            }
        }
        if (originalCalls.length > 0 && remainingCalls.length === 0) {
            dispatch(removeAllMedia());
        }
    };
}
function changeCallMode() {
    return;
}
function pauseCall() {
    return;
}
function resumeCall() {
    return;
}
function startRecording() {
    return;
}
function endRecording() {
    return;
}
function pauseRecording() {
    return;
}
function resumeRecording() {
    return;
}
/**
 * @description
 * Set the desired media preference for media received from peers in a specific call.
 *
 * Controls which media types are _received_ from peers. What media types are _sent_ to peers is left to you to control via `shareLocalMedia()` and `stopSharingLocalMedia()`.
 *
 * If set to 'video', full audio and video will be sent by peers when available.
 *
 * If set to 'audio', only audio and screen shares will be sent by peers.
 *
 * If set to 'none', peers will not send any media.
 *
 * @public
 *
 * @param roomAddress The address of the room hosting the call
 * @param mediaKind The kind of media you wish to receive from peers
 */
function setDesiredMediaForCall(roomAddress, desiredMedia) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                desiredMedia,
                roomAddress
            },
            type: SET_CALL_PREFERENCE
        });
        const state = getState();
        const client = getClient(state);
        if (client) {
            client.sendRoomPresence(roomAddress);
            client.mesh.updateConnections();
        }
    };
}
function updateCallState() {
    return;
}

// ====================================================================
/**
 * @description
 * Send a chat message to a room.
 *
 * @public
 *
 * @param roomAddress The address of the room to send the chat
 * @param opts See ChatOptions below
 */
function sendChat(roomAddress, opts) {
    return (dispatch, getState) => {
        const state = getState();
        const client = getClient(state);
        const id = opts.id || v4();
        const displayName = opts.displayName || getUserDisplayName(state);
        client.xmpp.sendMessage({
            body: opts.body,
            chatState: 'active',
            id,
            nick: displayName,
            replace: opts.replace,
            to: roomAddress,
            type: 'groupchat'
        });
        dispatch({
            payload: {
                acked: false,
                body: opts.body,
                direction: DIRECTION_OUTGOING,
                displayName,
                id,
                replace: opts.replace,
                roomAddress,
                time: new Date()
            },
            type: CHAT_OUTGOING
        });
    };
}
/**
 * @description
 * Send a chat state (typing) notification to a room.
 *
 * @public
 *
 * @param roomAddress The address of the room to send the chat state
 * @param chatState The state of the chat
 */
function sendChatState(roomAddress, chatState) {
    return (dispatch, getState) => {
        const client = getClient(getState());
        client.xmpp.sendMessage({
            chatState,
            to: roomAddress,
            type: 'groupchat'
        });
        dispatch({
            payload: {
                chatState,
                roomAddress
            },
            type: CHAT_STATE_OUTGOING
        });
    };
}
/**
 * Receive a chat message from a room.
 *
 * @private
 *
 * @param roomAddress string
 * @param senderAddress string
 * @param opts.body string
 * @param opts.displayName string
 * @param opts.id string
 * @param opts.replace string
 * @param opts.time Date
 */
function receiveChat(roomAddress, senderAddress, opts) {
    return {
        payload: {
            acked: true,
            body: opts.body,
            direction: DIRECTION_INCOMING,
            displayName: opts.displayName,
            id: opts.id,
            replace: opts.replace,
            roomAddress,
            senderAddress,
            time: opts.time || new Date()
        },
        type: CHAT_INCOMING
    };
}
/**
 * @description
 * Send a realtime-text update to a room.
 *
 * @public
 *
 * @param roomAddress The address of the room to send the RTT update
 * @param rtt
 */
function sendRTT(roomAddress, rtt) {
    return (dispatch, getState) => {
        const client = getClient(getState());
        let chatState;
        if (rtt.event !== 'init' && rtt.event !== 'cancel') {
            chatState = 'composing';
        }
        client.xmpp.sendMessage({
            chatState,
            rtt,
            to: roomAddress,
            type: 'groupchat'
        });
        dispatch({
            payload: {
                roomAddress,
                rtt
            },
            type: RTT_OUTGOING
        });
    };
}

// ====================================================================
/**
 * Start tracking a peer connection.
 *
 * @private
 *
 * @param peerAddress string
 * @param sessionId string
 */
function addConnection(peerAddress, sessionId) {
    const roomAddress = jid.parse(peerAddress).bare;
    return {
        payload: {
            id: sessionId,
            peerAddress,
            roomAddress
        },
        type: PEER_CONNECTION_ADDED
    };
}
/**
 * Stop tracking a peer connection.
 *
 * @private
 *
 * @param peerAddress string
 * @param sessionId string
 */
function removeConnection(peerAddress, sessionId) {
    return {
        payload: {
            id: sessionId,
            peerAddress
        },
        type: PEER_CONNECTION_REMOVED
    };
}
/**
 * Update the state of a peer connection.
 *
 * @private
 *
 * @param peerAddress string
 * @param sessionId string
 * @param updated.connectionState string
 * @param updated.receivingAudioMediaId string
 * @param updated.receivingVideoMediaId string
 * @param updated.sendingAudioMediaId string
 * @param updated.sendingVideoMediaId string
 */
function updateConnection(peerAddress, sessionId, updated) {
    return {
        payload: {
            id: sessionId,
            peerAddress,
            updated
        },
        type: PEER_CONNECTION_UPDATED
    };
}

// =====================================================================
let deviceListener;
let devicePollInterval;
// =====================================================================
/**
 * @description
 * Begin listening for media device changes.
 *
 * @public
 */
function listenForDevices() {
    return (dispatch, getState) => {
        if (!navigator.mediaDevices) {
            return;
        }
        if (!deviceListener) {
            deviceListener = () => {
                dispatch(fetchDevices());
            };
        }
        deviceListener();
        navigator.mediaDevices.addEventListener('devicechange', deviceListener);
        // Safari 12.0 does not emit device change events, but does update its
        // list of devices current.
        if (window.safari) {
            devicePollInterval = setInterval(() => {
                if (deviceListener) {
                    deviceListener();
                }
            }, 1000);
        }
    };
}
/**
 * @description
 * Fetch devices.
 *
 * @public
 */
function fetchDevices() {
    return (dispatch) => __awaiter(this, void 0, void 0, function* () {
        if (!navigator.mediaDevices) {
            return;
        }
        const devices = yield navigator.mediaDevices.enumerateDevices();
        return dispatch(deviceList(devices));
    });
}
/**
 * @description
 * Stop listening for media device changes.
 *
 * @public
 */
function stopListeningForDevices() {
    if (deviceListener) {
        navigator.mediaDevices.removeEventListener('devicechange', deviceListener);
        deviceListener = undefined;
    }
    if (devicePollInterval) {
        clearInterval(devicePollInterval);
        devicePollInterval = undefined;
    }
}
/**
 * Device list changed.
 *
 * @private
 *
 * @param devices Device[]
 */
function deviceList(devices) {
    devices = devices.filter(d => {
        // Work around Safari reporting the built-in speakers as a microphone
        if (d.kind === 'audioinput' && d.label === 'MacBook Pro Speakers') {
            return false;
        }
        return true;
    });
    return {
        payload: devices,
        type: DEVICES
    };
}
/**
 * Camera permission denied
 *
 * @private
 *
 * @param error Error
 */
function cameraPermissionDenied(error) {
    return {
        payload: {
            error
        },
        type: CAMERA_PERMISSION_DENIED
    };
}
/**
 * Microphone permission denied
 *
 * @private
 *
 * @param error Error
 */
function microphonePermissionDenied(error) {
    return {
        payload: {
            error
        },
        type: MICROPHONE_PERMISSION_DENIED
    };
}
/**
 * Update device capture request status.
 *
 * @private
 *
 * @param error Error
 */
function deviceCaptureRequest(camera, microphone) {
    return {
        payload: {
            camera,
            microphone
        },
        type: DEVICE_CAPTURE
    };
}

// ====================================================================
/**
 * Fetch room configuration from the API.
 *
 * @private
 *
 * @param configUrl string
 * @param roomName string
 * @param auth string
 * @param maxTries number
 * @param timeout number
 */
function fetchRoomConfig(configUrl, roomName, auth, maxTries = 5, timeout = 1000) {
    return __awaiter(this, void 0, void 0, function* () {
        let attemptCount = 0;
        let error;
        while (attemptCount <= maxTries) {
            try {
                const data = yield fetch(configUrl, {
                    body: JSON.stringify({ name: roomName }),
                    headers: {
                        authorization: `Bearer ${auth}`
                    },
                    method: 'POST'
                });
                if (!data.ok) {
                    throw new Error('SimpleWebRTC room configuration request failed: ' + data.status);
                }
                const config = (yield data.json());
                return config;
            }
            catch (err) {
                error = err;
                attemptCount += 1;
                yield sleep(timeout);
            }
        }
        console.error('ESWRTC_002. View more information at https://docs.simplewebrtc.com');
        if (error) {
            throw error;
        }
        else {
            throw new Error('Could not fetch room config');
        }
    });
}
// ====================================================================
/**
 * @description
 * Attempt to join a room.
 *
 * @public
 *
 * @param roomAddress A user-friendly name for a room
 */
function joinRoom(roomName, opts = {}) {
    return (dispatch, getState) => __awaiter(this, void 0, void 0, function* () {
        const state = getState();
        const client = getClient(state);
        const apiConfig = getAPIConfig(state);
        try {
            const config = yield fetchRoomConfig(apiConfig.roomConfigUrl, roomName, apiConfig.credential);
            const existingRoom = getRoomByAddress(state, config.roomAddress);
            if (!existingRoom || (existingRoom && !existingRoom.joined)) {
                dispatch({
                    payload: {
                        autoJoinCall: isSupportedBrowser(state) &&
                            (opts.autoJoinCall === undefined ? true : opts.autoJoinCall),
                        providedPassword: opts.password,
                        providedRoomName: roomName,
                        roomAddress: config.roomAddress
                    },
                    type: JOIN_ROOM
                });
                if (client) {
                    client.joinRoom(config.roomAddress, opts.password, opts.autoJoinCall);
                }
            }
        }
        catch (err) {
            dispatch(joinRoomFailed('', false));
        }
    });
}
/**
 * An attempt to join a room failed.
 *
 * If a password is required to join the room, `passwordRequired` should be set to `true`.
 *
 * @private
 *
 * @param roomAddress string
 * @param passwordRequired boolean
 */
function joinRoomFailed(roomAddress, passwordRequired) {
    return {
        payload: {
            passwordRequired,
            roomAddress
        },
        type: JOIN_ROOM_FAILED
    };
}
/**
 * The attempt to join a room succeeded.
 *
 * @private
 *
 * @param roomAddress string
 */
function joinRoomSuccess(roomAddress, selfAddress, roomId, role, affiliation) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                affiliation,
                id: roomId,
                role,
                roomAddress,
                selfAddress
            },
            type: JOIN_ROOM_SUCCESS
        });
        const client = getClient(getState());
        if (client) {
            client.mesh.updateConnections();
        }
    };
}
/**
 * Update the user's information for the room.
 *
 * @private
 *
 * @param roomAddress string
 */
function selfUpdated(roomAddress, selfAddress, roomId, role, affiliation) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                affiliation,
                id: roomId,
                role,
                roomAddress,
                selfAddress
            },
            type: SELF_UPDATED
        });
    };
}
/**
 * @description
 * Leave a room.
 *
 * @public
 *
 * @param roomAddress The address of the room to leave
 */
function leaveRoom(roomAddress) {
    return (dispatch, getState) => {
        const state = getState();
        const client = getClient(state);
        dispatch(leaveCall(roomAddress));
        if (client) {
            client.sendRoomPresence(roomAddress, {
                type: 'unavailable'
            });
        }
        dispatch({
            payload: {
                roomAddress
            },
            type: LEAVE_ROOM
        });
        if (client) {
            client.mesh.updateConnections();
        }
    };
}
/**
 * @description
 * Lock a room.
 *
 * @public
 *
 * @param roomAddress The address of the room to lock
 * @param password The new room password
 */
function lockRoom(roomAddress, password) {
    return (dispatch, getState) => {
        const state = getState();
        const client = getClient(state);
        if (client) {
            client.lockRoom(roomAddress, password);
        }
        dispatch({
            payload: {
                password,
                roomAddress
            },
            type: LOCK_ROOM
        });
    };
}
/**
 * @description
 * Unlock a room to allow anyone to enter without needing a password.
 *
 * @public
 *
 * @param roomAddress The address of the room to unlock
 */
function unlockRoom(roomAddress) {
    return (dispatch, getState) => {
        const state = getState();
        const client = getClient(state);
        if (client) {
            client.unlockRoom(roomAddress);
        }
        dispatch({
            payload: {
                roomAddress
            },
            type: UNLOCK_ROOM
        });
    };
}
/**
 * @description
 * Destroy a room.
 *
 * @public
 *
 * @param roomAddress  The address of the room to destroy
 */
function destroyRoom(roomAddress) {
    return (dispatch, getState) => __awaiter(this, void 0, void 0, function* () {
        const state = getState();
        const client = getClient(state);
        try {
            if (client) {
                yield client.destroyRoom(roomAddress);
            }
            dispatch({
                payload: {
                    roomAddress
                },
                type: DESTROY_ROOM
            });
        }
        catch (err) {
            console.error(err);
        }
    });
}
/**
 * Room has been locked.
 *
 * @private
 *
 * @param roomAddress string
 * @param password string
 */
function roomLocked(roomAddress, password) {
    return {
        payload: {
            password,
            roomAddress
        },
        type: ROOM_LOCKED
    };
}
/**
 * Room has been unlocked.
 *
 * @private
 *
 * @param roomAddress string
 */
function roomUnlocked(roomAddress) {
    return {
        payload: {
            roomAddress
        },
        type: ROOM_UNLOCKED
    };
}

// ====================================================================
/**
 * @description
 * Set the preferred display name for the user.
 *
 * Multiple people may have the same display name.
 *
 * Display names are _not_ unique.
 *
 * @public
 *
 * @param displayName The new display name that other peers will see
 */
function setDisplayName(displayName) {
    return (dispatch, getState) => {
        const state = getState();
        const client = getClient(state);
        dispatch({
            payload: {
                displayName
            },
            type: SET_USER_PREFERENCE
        });
        if (client) {
            client.sendAllRoomsPresence();
        }
    };
}
/**
 * @description
 * Set the default user preference for media received from peers.
 *
 * Controls which media types are _received_ from peers. What media types are _sent_ to peers is left to you to control via `shareLocalMedia()` and `stopSharingLocalMedia()`.
 *
 * If set to 'video', full audio and video will be sent by peers when available.
 *
 * If set to 'audio', only audio and screen shares will be sent by peers.
 *
 * If set to 'none', peers will not send any media.
 *
 * @public
 *
 * @param mediaKind The kind of media you wish to receive from peers
 */
function setDesiredMedia(mediaKind) {
    return (dispatch, getState) => {
        const state = getState();
        const client = getClient(state);
        dispatch({
            payload: {
                requestingMedia: mediaKind
            },
            type: SET_USER_PREFERENCE
        });
        const calls = getJoinedCalls(state);
        for (const call of calls) {
            dispatch(setDesiredMediaForCall(call.roomAddress, mediaKind));
        }
        if (client) {
            client.sendAllRoomsPresence();
        }
    };
}
/**
 * @description
 * Set the voice activity detection threshold.
 *
 * The number MUST be negative (defaults to -65).
 *
 * @public
 *
 * @param threshold The threshold to detect voice activity
 */
function setVoiceActivityThreshold(threshold = -65) {
    return {
        payload: {
            voiceActivityThreshold: threshold
        },
        type: SET_USER_PREFERENCE
    };
}
/**
 * @description
 * Enable or disable the use of push-to-talk.
 *
 * @public
 *
 * @param enabled Whether to enable push-to-talk
 */
function setPushToTalk(enabled) {
    return {
        payload: {
            pushToTalk: enabled
        },
        type: SET_USER_PREFERENCE
    };
}
/**
 * @description
 * Set the preferred audio output device.
 *
 * Expicitly pick an audio output sink in supported browsers.
 *
 * By default, browsers will try to use the same device capturing the audio input (e.g. using headset output when the input is the headset mic)
 *
 * @public
 *
 * @param deviceId The id of the device
 */
function setAudioOutputDevice(deviceId) {
    return {
        payload: {
            audioOutputDeviceId: deviceId
        },
        type: SET_USER_PREFERENCE
    };
}
/**
 * @description
 * Set the global output volume limit.
 *
 * The number MUST be between 0 and 1, inclusive (defaults to 1).
 *
 * Scale audio output volume without needing to use the OS volume controls. Useful if your application is expected to be running alongside other applications playing audio.
 *
 * @public
 *
 * @param globalVolumeLimit A value between 0 and 1 inclusive for scaling audio volume
 */
function setGlobalVolumeLimit(globalVolumeLimit = 1) {
    return {
        payload: {
            globalVolumeLimit
        },
        type: SET_USER_PREFERENCE
    };
}

// ====================================================================
/**
 * Add a new peer for a room.
 *
 * @private
 *
 * @param roomAddress string
 * @param peerAddress string
 */
function peerOnline(roomAddress, peerAddress, opts) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                affiliation: opts.affiliation,
                customerData: opts.customerData,
                displayName: opts.displayName,
                id: opts.id,
                joinedCall: opts.joinedCall || false,
                peerAddress,
                requestingMedia: opts.requestingMedia || 'none',
                role: opts.role,
                roomAddress
            },
            type: PEER_ONLINE
        });
        const client = getClient(getState());
        if (client) {
            client.mesh.updateConnections();
        }
    };
}
/**
 * Mark a peer as offline.
 *
 * @private
 *
 * @param roomAddress string
 * @param peerAddress string
 */
function peerOffline(roomAddress, peerAddress) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                peerAddress,
                roomAddress
            },
            type: PEER_OFFLINE
        });
    };
}
/**
 * Update a peer's information.
 *
 * @private
 *
 * @param peerAddress string
 * @param updated.chatState 'active' | 'composing' | 'paused'
 * @param updated.displayName string
 * @param updated.speaking boolean
 * @param updated.requestingAttention boolean
 * @param updated.rtt string
 * @param updated.customerData object
 * @param updated.volumeLimit number
 * @param updated.joinedCall boolean
 * @param updated.requestingMedia 'video' | 'audio' | 'none'
 * @param updated.sessionFailed boolean
 */
function peerUpdated(peerAddress, updated) {
    return (dispatch, getState) => {
        dispatch({
            payload: {
                peerAddress,
                updated
            },
            type: PEER_UPDATED
        });
        const client = getClient(getState());
        if (client) {
            client.mesh.updateConnections();
        }
    };
}
/**
 * @description
 * Kick a peer from the room.
 *
 * Only takes effect if the kicker is a room moderator.
 *
 * @public
 *
 * @param roomAddress The address of the room
 * @param peerAddress The address of the peer to remove from the room
 */
function kickPeer(roomAddress, peerAddress) {
    return {
        payload: {
            peerAddress,
            roomAddress
        },
        type: KICK_PEER
    };
}
/**
 * @description
 * Set the overall volume limit for a peer.
 *
 * The volume limit must be between 0 and 1.
 *
 * @public
 *
 * @param peerAddress The address of the peer to adjust
 * @param volumeLimit The new volume limit, from 0 to 1 inclusive
 */
function limitPeerVolume(peerAddress, volumeLimit) {
    return {
        payload: {
            peerAddress,
            updated: {
                volumeLimit
            }
        },
        type: PEER_UPDATED
    };
}



var index = /*#__PURE__*/Object.freeze({
    sleep: sleep,
    fetchConfig: fetchConfig,
    connect: connect,
    disconnect: disconnect,
    receivedConfig: receivedConfig,
    receivedConfigError: receivedConfigError,
    queueTelemetry: queueTelemetry,
    sendQueuedTelemetry: sendQueuedTelemetry,
    telemetrySucess: telemetrySucess,
    enableTelemetry: enableTelemetry,
    disableTelemetry: disableTelemetry,
    connectionStateChanged: connectionStateChanged,
    startCall: startCall,
    endCall: endCall,
    joinCall: joinCall,
    leaveCall: leaveCall,
    changeCallMode: changeCallMode,
    pauseCall: pauseCall,
    resumeCall: resumeCall,
    startRecording: startRecording,
    endRecording: endRecording,
    pauseRecording: pauseRecording,
    resumeRecording: resumeRecording,
    setDesiredMediaForCall: setDesiredMediaForCall,
    updateCallState: updateCallState,
    sendChat: sendChat,
    sendChatState: sendChatState,
    receiveChat: receiveChat,
    sendRTT: sendRTT,
    addConnection: addConnection,
    removeConnection: removeConnection,
    updateConnection: updateConnection,
    listenForDevices: listenForDevices,
    fetchDevices: fetchDevices,
    stopListeningForDevices: stopListeningForDevices,
    deviceList: deviceList,
    cameraPermissionDenied: cameraPermissionDenied,
    microphonePermissionDenied: microphonePermissionDenied,
    deviceCaptureRequest: deviceCaptureRequest,
    fetchRoomConfig: fetchRoomConfig,
    joinRoom: joinRoom,
    joinRoomFailed: joinRoomFailed,
    joinRoomSuccess: joinRoomSuccess,
    selfUpdated: selfUpdated,
    leaveRoom: leaveRoom,
    lockRoom: lockRoom,
    unlockRoom: unlockRoom,
    destroyRoom: destroyRoom,
    roomLocked: roomLocked,
    roomUnlocked: roomUnlocked,
    setDisplayName: setDisplayName,
    setDesiredMedia: setDesiredMedia,
    setVoiceActivityThreshold: setVoiceActivityThreshold,
    setPushToTalk: setPushToTalk,
    setAudioOutputDevice: setAudioOutputDevice,
    setGlobalVolumeLimit: setGlobalVolumeLimit,
    peerOnline: peerOnline,
    peerOffline: peerOffline,
    peerUpdated: peerUpdated,
    kickPeer: kickPeer,
    limitPeerVolume: limitPeerVolume,
    addLocalMedia: addLocalMedia,
    addLocalAudio: addLocalAudio,
    addLocalVideo: addLocalVideo,
    addLocalScreen: addLocalScreen,
    addRemoteMedia: addRemoteMedia,
    removeMedia: removeMedia,
    updateMedia: updateMedia,
    enableMedia: enableMedia,
    disableMedia: disableMedia,
    shareLocalMedia: shareLocalMedia,
    stopSharingLocalMedia: stopSharingLocalMedia,
    adjustVideoCaptureResolution: adjustVideoCaptureResolution,
    setVideoResolutionTiers: setVideoResolutionTiers,
    mutePeer: mutePeer,
    unmutePeer: unmutePeer,
    muteSelf: muteSelf,
    unmuteSelf: unmuteSelf,
    pauseSelfVideo: pauseSelfVideo,
    resumeSelfVideo: resumeSelfVideo,
    removeAllMedia: removeAllMedia
});

const SESSION_STORAGE_KEY = 'getScreenMediaJSExtensionId';
// ====================================================================
/**
 * @description
 * Check if screensharing is available for this browser.
 *
 * @public
 */
function isAvailable() {
    // Chrome
    if (!!window.chrome) {
        return true;
    }
    // Firefox
    if (!!window.InstallTrigger) {
        return true;
    }
    if ('getDisplayMedia' in window.navigator.mediaDevices) {
        return true;
    }
    return false;
}
/**
 * @description
 * Check if screensharing requires a browser extension.
 *
 * @public
 */
function requiresExtension() {
    // Chrome
    if (!!window.chrome && webrtc.browserDetails.version < 72) {
        return true;
    }
    return false;
}
/**
 * Check if the screensharing extension has already been installed.
 *
 * This is an asynchronous install check that attempts to communicate with
 * the extension.
 *
 * The user gesture flag will be lost when an answer is received, so this
 * function can not be used when a user gesture is required. For those cases,
 * use `checkForExtensionSync` instead to know if the extension _might_ be
 * already installed.
 *
 * @param extensionId string WebStore ID of the screensharing extension
 */
function checkForExtension(extensionId) {
    const runtime = window.chrome.runtime;
    return new Promise((resolve, reject) => {
        runtime.sendMessage(extensionId, { type: 'isInstalled' }, null, (data) => {
            if (!data || !data.installed || !data.extensionId) {
                resolve(false);
                return;
            }
            sessionStorage.setItem(SESSION_STORAGE_KEY, data.extensionId);
            resolve(true);
        });
    });
}
/**
 * Check if the screensharing extension has _possibly_ been installed.
 *
 * This is a synchronous installation check so that user gesture status
 * can be retained.
 *
 * This only checks that the extension ID has been set in sessionStorage. If
 * the extension was removed while the session was active, this function will
 * still return `true` unless the sessionStorage key is manually cleared.
 *
 * @param extensionId string WebStore ID of the screensharing extension
 */
function checkForExtensionSync(extensionId) {
    return sessionStorage[SESSION_STORAGE_KEY] === extensionId;
}
/**
 * Get the URL for the Chrome WebStore page for the screensharing extension.
 *
 * @param extensionId string WebStore ID of the screensharing extension
 */
function getExtensionURL(extensionId) {
    return `https://chrome.google.com/webstore/detail/${extensionId}`;
}

var ScreenSharingHelpers = /*#__PURE__*/Object.freeze({
    isAvailable: isAvailable,
    requiresExtension: requiresExtension,
    checkForExtension: checkForExtension,
    checkForExtensionSync: checkForExtensionSync,
    getExtensionURL: getExtensionURL
});

const INITIAL_STATE = {
    config: {
        apiVersion: '',
        credential: '',
        customerData: {},
        iceServers: [],
        id: '',
        orgId: '',
        roomConfigUrl: '',
        screensharingExtensions: {
            chrome: ''
        },
        signalingUrl: '',
        telemetryUrl: '',
        userId: ''
    },
    configUrl: '',
    connectionAttempts: 0,
    connectionState: 'disconnected',
    queuedTelemetry: [],
    signalingClient: undefined,
    token: '',
    videoResolutionTiers: [
        [0, { width: 800, height: 600, frameRate: 30 }],
        [1, { width: 800, height: 600, frameRate: 30 }],
        [2, { width: 640, height: 480, frameRate: 30 }],
        [3, { width: 320, height: 240, frameRate: 15 }],
        [5, { width: 320, height: 240, frameRate: 10 }]
    ]
};
function APIReducer (state = INITIAL_STATE, action) {
    switch (action.type) {
        case SIGNALING_CLIENT:
            return Object.assign({}, state, { signalingClient: action.payload });
        case SIGNALING_CLIENT_SHUTDOWN:
            return Object.assign({}, state, { connectionState: 'disconnected', signalingClient: undefined });
        case CONNECTION_STATE_CHANGE:
            return Object.assign({}, state, { connectionState: action.payload });
        case RECEIVED_CONFIG: {
            const config = action.payload.config;
            const configUrl = action.payload.configUrl;
            const token = action.payload.token || '';
            return Object.assign({}, state, { config: Object.assign({}, state.config, config), configUrl,
                token });
        }
        case QUEUE_TELEMETRY:
            return Object.assign({}, state, { queuedTelemetry: [...state.queuedTelemetry, action.payload] });
        case TELEMETRY_SUCCESS:
            return Object.assign({}, state, { queuedTelemetry: state.queuedTelemetry.slice(action.payload) });
        case SET_VIDEO_RESOLUTION_TIERS:
            return Object.assign({}, state, { videoResolutionTiers: action.payload.videoResolutionTiers });
    }
    return state;
}

const INITIAL_STATE$1 = {};
function addCall(state, action) {
    return Object.assign({}, state, { [action.payload.roomAddress]: {
            allowedAudioRoles: ['moderator', 'participant'],
            allowedMedia: 'video',
            allowedVideoRoles: ['moderator', 'participant'],
            joined: false,
            joinedAt: undefined,
            recordable: false,
            recordingState: 'offline',
            requestingMedia: undefined,
            roomAddress: action.payload.roomAddress,
            state: 'active'
        } });
}
function updatedCall(state, action) {
    if (!state[action.payload.roomAddress]) {
        state = addCall(state, action);
    }
    if (action.type === JOIN_CALL) {
        return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, state[action.payload.roomAddress], { joined: true, joinedAt: new Date(Date.now()), requestingMedia: action.payload.desiredMedia }) });
    }
    if (action.type === LEAVE_CALL) {
        return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, state[action.payload.roomAddress], { joined: false, joinedAt: undefined, requestingMedia: undefined }) });
    }
    if (action.type === SET_CALL_PREFERENCE) {
        return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, state[action.payload.roomAddress], { requestingMedia: action.payload.desiredMedia }) });
    }
    return state;
}
function removeCall(state, action) {
    const result = Object.assign({}, state);
    delete result[action.payload.roomAddress];
    return result;
}
function CallsReducer (state = INITIAL_STATE$1, action) {
    switch (action.type) {
        case JOIN_CALL:
            return updatedCall(state, action);
        case LEAVE_CALL:
            return updatedCall(state, action);
        case LEAVE_ROOM:
            return removeCall(state, action);
        case JOIN_ROOM_SUCCESS:
            return updatedCall(state, action);
        case SET_CALL_PREFERENCE:
            return updatedCall(state, action);
    }
    return state;
}

const INITIAL_STATE$2 = {};
function addChat(state, action) {
    if (action.type === CHAT_INCOMING) {
        const chat = action.payload;
        const existing = state[chat.id];
        if (chat.replace) {
            const original = state[chat.replace];
            if (original && original.direction === DIRECTION_OUTGOING) {
                return Object.assign({}, state, { [chat.id]: Object.assign({}, existing, { acked: true, body: chat.body }) });
            }
        }
        if (!existing) {
            return Object.assign({}, state, { [chat.id]: chat });
        }
        if (existing.direction === DIRECTION_OUTGOING) {
            return Object.assign({}, state, { [chat.id]: Object.assign({}, existing, { acked: true, body: chat.body, time: chat.time }) });
        }
    }
    if (action.type === CHAT_OUTGOING) {
        const chat = action.payload;
        const existing = state[chat.id];
        return Object.assign({}, state, { [chat.id]: editChat(existing, chat) });
    }
    return state;
}
function editChat(original, replacement) {
    if (!original) {
        return replacement;
    }
    return Object.assign({}, replacement, { editedTime: replacement.time, time: original.time });
}
function ChatReducer (state = INITIAL_STATE$2, action) {
    switch (action.type) {
        case CHAT_INCOMING:
            return addChat(state, action);
        case CHAT_OUTGOING:
            return addChat(state, action);
    }
    return state;
}

const INITIAL_STATE$3 = {};
function addConnection$1(state, action) {
    return Object.assign({}, state, { [action.payload.id]: {
            connectionState: '',
            id: action.payload.id,
            peerAddress: action.payload.peerAddress,
            receivingAudioMediaId: '',
            receivingVideoMediaId: '',
            restarting: false,
            roomAddress: action.payload.roomAddress,
            sendingAudioMediaId: '',
            sendingVideoMediaId: '',
            sessionState: ''
        } });
}
function updateConnection$1(state, action) {
    if (!state[action.payload.id]) {
        return state;
    }
    return Object.assign({}, state, { [action.payload.id]: Object.assign({}, (state[action.payload.id] || {}), { peerAddress: action.payload.peerAddress }, action.payload.updated) });
}
function removeConnection$1(state, action) {
    const result = Object.assign({}, state);
    delete result[action.payload.id];
    return result;
}
function ConnectionsReducer (state = INITIAL_STATE$3, action) {
    switch (action.type) {
        case PEER_CONNECTION_ADDED:
            return addConnection$1(state, action);
        case PEER_CONNECTION_UPDATED:
            return updateConnection$1(state, action);
        case PEER_CONNECTION_REMOVED:
            return removeConnection$1(state, action);
    }
    return state;
}

const INITIAL_STATE$4 = {
    cameraPermissionDenied: false,
    cameraPermissionGranted: false,
    devices: [],
    hasAudioOutput: false,
    hasCamera: false,
    hasMicrophone: false,
    microphonePermissionDenied: false,
    microphonePermissionGranted: false,
    requestingCameraCapture: false,
    requestingCapture: false,
    requestingMicrophoneCapture: false
};
function DevicesReducer (state = INITIAL_STATE$4, action) {
    if (action.type === DEVICES) {
        const devices = action.payload;
        const audioInputs = devices.filter(d => d.kind === 'audioinput');
        const videoInputs = devices.filter(d => d.kind === 'videoinput');
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');
        return Object.assign({}, state, { cameraPermissionGranted: videoInputs.filter(d => !!d.label).length > 0, devices: devices.filter(d => !!d.label), hasAudioOutput: audioOutputs.length > 0, hasCamera: videoInputs.length > 0, hasMicrophone: audioInputs.length > 0, microphonePermissionGranted: audioInputs.filter(d => !!d.label).length > 0 });
    }
    if (action.type === CAMERA_PERMISSION_DENIED) {
        return Object.assign({}, state, { cameraPermissionDenied: true });
    }
    if (action.type === MICROPHONE_PERMISSION_DENIED) {
        return Object.assign({}, state, { microphonePermissionDenied: true });
    }
    if (action.type === DEVICE_CAPTURE) {
        return Object.assign({}, state, { requestingCameraCapture: action.payload.camera, requestingCapture: action.payload.camera || action.payload.microphone, requestingMicrophoneCapture: action.payload.microphone });
    }
    return state;
}

const INITIAL_STATE$5 = {};
function addMedia(state, action) {
    return Object.assign({}, state, { [action.payload.id]: action.payload });
}
// TODO: typedoc merges this definition with the action of the same name making it
// impossible to generate docs for the action
function removeMediaReducer(state, action) {
    const result = Object.assign({}, state);
    delete result[action.payload.id];
    return result;
}
function updatedMedia(state, action) {
    const existing = state[action.payload.id];
    if (!existing) {
        return state;
    }
    return Object.assign({}, state, { [action.payload.id]: Object.assign({}, existing, action.payload.updated) });
}
function removeCallMedia(state, action) {
    const result = Object.assign({}, state);
    for (const id of Object.keys(state)) {
        const media = state[id];
        if (media.source === 'remote' && media.roomAddress === action.payload.roomAddress) {
            delete result[id];
        }
    }
    return result || {};
}
function MediaReducer (state = INITIAL_STATE$5, action) {
    switch (action.type) {
        case ADD_MEDIA:
            return addMedia(state, action);
        case REMOVE_MEDIA:
            return removeMediaReducer(state, action);
        case MEDIA_UPDATED:
            return updatedMedia(state, action);
        case LEAVE_CALL:
            return removeCallMedia(state, action);
    }
    return state;
}

const INITIAL_STATE$6 = {};
function addPeer(state, action) {
    if (state[action.payload.peerAddress]) {
        return updatePeer(state, {
            payload: {
                peerAddress: action.payload.peerAddress,
                updated: action.payload
            },
            type: PEER_UPDATED
        });
    }
    const now = new Date(Date.now());
    return Object.assign({}, state, { [action.payload.peerAddress]: {
            address: action.payload.peerAddress,
            affiliation: action.payload.affiliation,
            chatState: 'active',
            customerData: action.payload.customerData || {},
            displayName: action.payload.displayName || '',
            id: action.payload.id,
            joinedCall: action.payload.joinedCall || false,
            joinedCallAt: action.payload.joinedCall ? now : undefined,
            joinedRoomAt: now,
            lastSpokeAt: undefined,
            muted: false,
            requestingAttention: false,
            requestingMedia: action.payload.requestingMedia || 'none',
            role: action.payload.role,
            roomAddress: action.payload.roomAddress,
            rtt: '',
            speaking: false,
            volume: -Infinity,
            volumeLimit: 0.8
        } });
}
function updatePeer(state, action) {
    const existingPeer = state[action.payload.peerAddress];
    if (!existingPeer) {
        return state;
    }
    const now = new Date(Date.now());
    let lastSpokeAt = existingPeer.lastSpokeAt;
    if (existingPeer.speaking && action.payload.updated.speaking === false) {
        lastSpokeAt = now;
    }
    let leftCall = false;
    if (existingPeer.joinedCall && action.payload.updated.joinedCall === false) {
        leftCall = true;
    }
    return Object.assign({}, state, { [action.payload.peerAddress]: Object.assign({}, existingPeer, action.payload.updated, { joinedCallAt: leftCall ? undefined : existingPeer.joinedCallAt || now, lastSpokeAt }) });
}
function removePeer(state, action) {
    const result = Object.assign({}, state);
    delete result[action.payload.peerAddress];
    return result;
}
function removeRoomPeers(state, action) {
    const result = Object.assign({}, state);
    for (const peerAddress of Object.keys(state)) {
        const peer = state[peerAddress];
        if (peer.roomAddress === action.payload.roomAddress) {
            delete result[peerAddress];
        }
    }
    return result;
}
function PeerReducer (state = INITIAL_STATE$6, action) {
    switch (action.type) {
        case PEER_ONLINE:
            return addPeer(state, action);
        case PEER_OFFLINE:
            return removePeer(state, action);
        case PEER_UPDATED:
            return updatePeer(state, action);
        case LEAVE_ROOM:
            return removeRoomPeers(state, action);
    }
    return state;
}

const INITIAL_STATE$7 = {};
function addRoom(state, action) {
    return Object.assign({}, state, { [action.payload.roomAddress]: {
            address: action.payload.roomAddress,
            autoJoinCall: !!action.payload.autoJoinCall,
            id: '',
            joined: false,
            joinedAt: undefined,
            password: action.payload.password || '',
            passwordRequired: false,
            providedName: action.payload.providedRoomName,
            providedPassword: action.payload.providedPassword,
            roomState: 'joining',
            selfAddress: '',
            selfAffiliation: 'none',
            selfRole: 'none',
            unreadCount: 0
        } });
}
function updateRoom(state, action) {
    const existingRoom = state[action.payload.roomAddress];
    if (!existingRoom) {
        return state;
    }
    if (action.type === JOIN_ROOM_FAILED) {
        return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, existingRoom, { joined: false, joinedAt: undefined, password: '', passwordRequired: !!action.payload.passwordRequired, roomState: !!action.payload.passwordRequired ? 'password-required' : 'failed' }) });
    }
    return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, existingRoom, { id: action.payload.id, joined: true, joinedAt: existingRoom.joinedAt || new Date(Date.now()), roomState: 'joined', selfAddress: action.payload.selfAddress, selfAffiliation: action.payload.affiliation, selfRole: action.payload.role }) });
}
function updateRoomLock(state, action) {
    const existingRoom = state[action.payload.roomAddress];
    if (!existingRoom) {
        return state;
    }
    switch (action.type) {
        case LOCK_ROOM:
            return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, existingRoom, { providedPassword: action.payload.password || '' }) });
        case ROOM_LOCKED:
            return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, existingRoom, { password: action.payload.password || '', passwordRequired: true, providedPassword: undefined }) });
        case ROOM_UNLOCKED:
            return Object.assign({}, state, { [action.payload.roomAddress]: Object.assign({}, existingRoom, { password: '', passwordRequired: false, providedPassword: undefined }) });
    }
    return state;
}
function removeRoom(state, action) {
    const result = Object.assign({}, state);
    delete result[action.payload.roomAddress];
    return result;
}
function RoomsReducer (state = INITIAL_STATE$7, action) {
    switch (action.type) {
        case SELF_UPDATED:
            return updateRoom(state, action);
        case JOIN_ROOM:
            return addRoom(state, action);
        case JOIN_ROOM_FAILED:
            return updateRoom(state, action);
        case JOIN_ROOM_SUCCESS:
            return updateRoom(state, action);
        case LEAVE_ROOM:
            return removeRoom(state, action);
        case LOCK_ROOM:
        case UNLOCK_ROOM:
        case ROOM_LOCKED:
        case ROOM_UNLOCKED:
            return updateRoomLock(state, action);
    }
    return state;
}

const INITIAL_STATE$8 = {
    displayName: '',
    globalVolumeLimit: 1,
    mediaEnabled: true,
    pushToTalk: false,
    requestingMedia: 'video',
    voiceActivityThreshold: -65
};
function updatePreference(state, action) {
    return Object.assign({}, state, action.payload);
}
function UserReducer (state = INITIAL_STATE$8, action) {
    switch (action.type) {
        case SET_USER_PREFERENCE:
            return updatePreference(state, action);
        case RECEIVED_CONFIG:
            return updatePreference(state, {
                payload: {
                    displayName: action.payload.config.displayName || state.displayName || 'Anonymous'
                },
                type: SET_USER_PREFERENCE
            });
        case DEVICES: {
            const outputDevice = state.audioOutputDeviceId;
            if (outputDevice) {
                for (const device of action.payload) {
                    if (device.id === outputDevice) {
                        return state;
                    }
                }
                // Our output device is no longer available
                return updatePreference(state, {
                    payload: {
                        audioOutputDeviceId: ''
                    },
                    type: SET_USER_PREFERENCE
                });
            }
            return state;
        }
    }
    return state;
}

const reducer = combineReducers({
    api: APIReducer,
    calls: CallsReducer,
    chats: ChatReducer,
    connections: ConnectionsReducer,
    devices: DevicesReducer,
    media: MediaReducer,
    peers: PeerReducer,
    rooms: RoomsReducer,
    user: UserReducer
});

/**
 * @description
 * Local and remote audio tracks can be played with the `<Audio/>` component.
 *
 * The provided `media` property can include `remoteDisabled` and `localDisabled` fields. If either of those properties are `true`, audio playback will be muted.
 *
 * @public
 *
 * @example
 * <Audio
 *  media={getMediaTrack(store, 'some-media-id')}
 *  volume={getGlobalVolumeLimit(store)}
 *  outputDevice={getAudioOutputDevice(store)}
 * />
 */
class Audio extends Component {
    componentDidMount() {
        this.setup();
    }
    componentDidUpdate(prev) {
        this.setup();
    }
    setup() {
        this.audio.oncontextmenu = e => {
            e.preventDefault();
        };
        if (this.audio.srcObject !== this.props.media.stream) {
            this.audio.srcObject = this.props.media.stream;
        }
        if (this.props.volume || this.props.volume === 0) {
            this.audio.volume = this.props.volume;
        }
        if (this.props.media.localDisabled ||
            this.props.media.remoteDisabled ||
            this.props.volume === 0) {
            this.audio.muted = true;
        }
        else {
            this.audio.muted = false;
        }
        if (this.props.outputDevice &&
            this.audio.sinkId !== this.props.outputDevice &&
            this.audio.setSinkId) {
            this.audio.pause();
            this.audio
                .setSinkId(this.props.outputDevice)
                .then(() => {
                this.audio.play();
            })
                .catch((err) => {
                this.audio.play();
                console.error(err);
            });
        }
        else {
            this.audio.autoplay = true;
        }
    }
    render() {
        return (createElement("audio", Object.assign({ ref: (el) => {
                this.audio = el;
            } }, { playsInline: true })));
    }
}

/**
 * @description
 *
 * @public
 *
 */
class PeerList extends Component {
    render() {
        const renderProps = {
            chatState: this.props.chatState || undefined,
            joinedCall: this.props.joinedCall || false,
            peers: this.props.peers || [],
            speaking: this.props.speaking || false
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function mapStateToProps(state, props) {
    const filters = [
        'joinedCall',
        'speaking',
        'chatState',
        'requestingAttention'
    ];
    const peers = getPeersForRoom(state, props.room).filter((peer) => {
        for (const filter of filters) {
            if (props[filter] !== undefined && peer[filter] !== props[filter]) {
                return false;
            }
        }
        return true;
    });
    return Object.assign({}, props, { peers });
}
var PeerList$1 = connect$1(mapStateToProps)(PeerList);

/**
 * @description
 *
 * @public
 *
 */
class ChatComposers extends Component {
    render() {
        const renderProps = {
            composers: this.props.composers || []
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        if (render) {
            return (createElement(PeerList$1, { room: this.props.room, chatState: "composing", render: ({ peers }) => render({ composers: peers }) }));
        }
        else if (this.props.children) {
            return (createElement(PeerList$1, { room: this.props.room, chatState: "composing" }, this.props.children));
        }
        return (createElement(PeerList$1, { room: this.props.room, chatState: "composing", render: ({ peers }) => {
                switch (peers.length) {
                    case 0:
                        return null;
                    case 1: {
                        const peer0 = peers[0].displayName || 'Anonymous';
                        return createElement("div", { className: this.props.className }, `${peer0} is typing...`);
                    }
                    case 2: {
                        const peer0 = peers[0].displayName || 'Anonymous';
                        const peer1 = peers[1].displayName || 'Anonymous';
                        return (createElement("div", { className: this.props.className }, `${peer0} and ${peer1} are typing...`));
                    }
                    default:
                        return createElement("div", { className: this.props.className }, "People are typing...");
                }
            } }));
    }
}

/**
 * @description
 *
 * @public
 *
 */
class ChatInput extends Component {
    constructor(props) {
        super(props);
        this.rttBuffer = new InputBuffer();
        this.state = {
            chatState: 'active',
            message: ''
        };
    }
    componentDidUpdate(prev) {
        if (!prev.rtt && this.props.rtt) {
            this.props.onRtt(this.rttBuffer.start());
            this.rttBuffer.update(this.state.message);
        }
        if (prev.rtt && !this.props.rtt) {
            this.props.onRtt(this.rttBuffer.stop());
            clearInterval(this.rttInterval);
            this.rttInterval = null;
        }
    }
    startSendingRtt() {
        if (!this.rttInterval && this.props.rtt) {
            this.rttInterval = setInterval(this.rttSend.bind(this), 700);
            setTimeout(this.rttSend.bind(this), 100);
        }
    }
    rttUpdate(data = '') {
        this.rttBuffer.update(data);
        this.startSendingRtt();
    }
    rttSend() {
        if (!this.props.rtt) {
            return;
        }
        const diff = this.rttBuffer.diff();
        if (diff) {
            this.props.onRtt(diff);
        }
    }
    commitMessage() {
        if (this.props.disabled || this.state.message.length === 0) {
            return;
        }
        clearTimeout(this.pausedTimeout);
        this.pausedTimeout = null;
        clearInterval(this.rttInterval);
        this.rttInterval = null;
        const { message } = this.state;
        this.setState({ message: '', chatState: 'active' });
        this.rttBuffer.commit();
        if (this.props.onChat) {
            this.props.onChat({
                body: message
            });
        }
    }
    updateChatState(chatState) {
        if (this.pausedTimeout) {
            clearTimeout(this.pausedTimeout);
        }
        if (chatState === 'composing') {
            this.pausedTimeout = setTimeout(() => {
                this.updateChatState('paused');
            }, 10000);
        }
        else {
            this.pausedTimeout = null;
        }
        if (chatState !== this.state.chatState) {
            if (this.props.onChatState) {
                this.props.onChatState(chatState);
            }
        }
        this.setState({
            chatState
        });
    }
    render() {
        return (createElement("textarea", { id: this.props.id, value: this.state.message, placeholder: this.props.placeholder, disabled: this.props.disabled, onInput: event => {
                const value = event.target.value;
                this.rttUpdate(value);
                if (value !== '') {
                    this.updateChatState('composing');
                }
                if (this.state.message !== '' && value === '') {
                    this.updateChatState('active');
                }
                this.setState({
                    message: value
                });
            }, onChange: () => null, onKeyPress: event => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.commitMessage();
                }
            } }));
    }
}
function mapStateToProps$1(state, props) {
    return props;
}
function mapDispatchToProps(dispatch, props) {
    return {
        onChat: (opts) => dispatch(sendChat(props.room, opts)),
        onChatState: (state) => dispatch(sendChatState(props.room, state)),
        onRtt: (data) => dispatch(sendRTT(props.room, data))
    };
}
var ChatInput$1 = connect$1(mapStateToProps$1, mapDispatchToProps)(ChatInput);

function StayDown(opts) {

    opts = opts || {};
    this.target = opts.target;
    this.interval = opts.interval | 1000;
    this.max = opts.max || 0;
    this.callback = opts.callback;
    this.userScroll = true;
    this.spinner = opts.spinner;
    this.spin_img = new Image();
    this.stickyHeight = opts.stickyHeight || 10;
    if (this.spinner) {
        this.spin_img.src = this.spinner;
    }
    var staydown = this;
    this.intend_down = true;

    this.emit('lock');
    if (document.onmousewheel !== undefined) ;

    window.addEventListener('resize', function (event) {
        staydown.emit('windowresize');
        staydown.checkdown();
    });

    this.target.addEventListener('scroll', function (event) {
        if (staydown.userScroll) {
            if (staydown.intend_down && !staydown.isdown()) {
                staydown.intend_down = false;
                staydown.emit('release');
            } else if (!staydown.intend_down && staydown.isdown()) {
                staydown.intend_down = true;
                staydown.emit('lock');
            }
        }
        staydown.userScroll = true;
    });

    if (window.MutationObserver) {
        //private function for getting images recursively from dom

        //mutation observer for whenever the overflow element changes
        this.mo = new MutationObserver(function (mutations) {
            var mut, idx, nidx, imgs, img, iidx, ilen, parent, spin;
            staydown.userScroll = false;
            //something changed, check scroll
            staydown.checkdown();
            //check to see if image was added, and add onload check
            for (idx = 0; idx < mutations.length; idx++) {
                mut = mutations[idx];
                for (nidx = 0; nidx < mut.addedNodes.length; nidx++) {
                    // Check if we appended a node type that isn't
                    // an element that we can search for images inside.
                    if (!mut.addedNodes[nidx].getElementsByTagName) {
                        continue;
                    }

                    imgs = mut.addedNodes[nidx].getElementsByTagName('img');
                    for (iidx = 0, ilen = imgs.length; iidx < ilen; iidx++) {
                        img = imgs[iidx];
                        if (!img.complete) {
                            parent = img.parentNode;
                            if (staydown.spinner) {
                                spin = staydown.spin_img.cloneNode();
                                parent.replaceChild(spin, img);
                            }
                            var onImageLoad = function (event) {
                                if (spin) {
                                    //image loads later, and isn't a mutation
                                    parent.replaceChild(img, spin);
                                }
                                staydown.emit('imageload');
                                staydown.checkdown();
                                event.target.removeEventListener('load', onImageLoad);
                            };
                            img.addEventListener('load', onImageLoad);
                        }
                    }
                }
            }
        });
        this.mo.observe(this.target, {attributes: true, childList: true, characterData: true, subtree: true});
    } else {
        var checkdown = function () {
            staydown.checkdown();
            window.setTimeout(checkdown, staydown.interval);
        };
        checkdown();
    }

}

(function () {

    this.isdown = function () {
        var position = this.target.scrollHeight - this.target.scrollTop - this.target.clientHeight;
        return position < this.stickyHeight;
    };

    this.append = function (newel) {
        this.emit('append');
        this.target.appendChild(newel);
        if (this.intend_down) {
            this.target.scrollTop = this.target.scrollHeight;
            this.emit('scrolldown');
        }
        while (this.max !== 0 && this.target.children.length > this.max) {
            this.target.removeChild(this.target.children[0]);
            this.emit('removechild');
        }
    };

    this.emit = function (type, msg) {
        if (typeof this.callback === 'function') {
            this.callback(type, msg);
        }
    };

    this.checkdown = function () {
        var position = this.target.scrollHeight - this.target.scrollTop - this.target.clientHeight;
        if (this.intend_down || position < this.stickyHeight) {
            this.target.scrollTop = this.target.scrollHeight;
            this.userScroll = false;
            this.emit('scrolldown');
        }
    };

}).call(StayDown.prototype);

/**
 * @description
 *  The `<StayDownContainer/>` component forces its view to stay pinned to the bottom of its scrollable area, unless the user scrolls away from the bottom.
 *
 * It's especially suited for chat UIs so that new messages are displayed at the bottom but still kept visible unless the user has scrolled back to read past messages.
 *
 * @public
 *
 */
class StayDownContainer extends Component {
    render() {
        return (createElement("div", Object.assign({}, this.props, { ref: (el) => {
                if (!el) {
                    return;
                }
                const staydown = new StayDown({ target: el, stickyHeight: 30 });
                if (this.staydown) {
                    staydown.intend_down = this.staydown.intend_down;
                    staydown.userScroll = this.staydown.userScroll;
                }
                this.staydown = staydown;
                this.staydown.checkdown();
            } })));
    }
}

class ChatListGroup extends Component {
    render() {
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        if (render) {
            return render(this.props);
        }
        if (this.props.children) {
            return this.props.children;
        }
        return (createElement("div", null,
            createElement("span", null, this.props.displayName),
            this.props.chats.map(chat => (createElement("div", null, chat.body)))));
    }
}
/**
 * @description
 *
 * @public
 *
 */
class ChatList extends Component {
    render() {
        const groups = this.props.groups || [];
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        if (render) {
            return render({ groups });
        }
        if (this.props.children) {
            return this.props.children;
        }
        return (createElement(StayDownContainer, { id: this.props.id, className: this.props.className }, groups.map(group => {
            if (this.props.renderGroup) {
                return this.props.renderGroup(group);
            }
            else {
                return createElement(ChatListGroup, Object.assign({}, group));
            }
        })));
    }
}
function mapStateToProps$2(state, props) {
    if (!props.room) {
        return Object.assign({}, props, { groups: [] });
    }
    return Object.assign({}, props, { groups: getGroupedChatsForRoom(state, props.room, props.maxGroupDuration) || [] });
}
var ChatList$1 = connect$1(mapStateToProps$2)(ChatList);

/**
 * @description
 *
 * @public
 *
 */
class DeviceList extends Component {
    componentDidMount() {
        this.props.listenForDevices();
        this.props.fetchDevices();
    }
    render() {
        const renderProps = {
            audioInput: this.props.audioInput,
            audioOutput: this.props.audioOutput,
            cameraPermissionDenied: this.props.cameraPermissionDenied,
            cameraPermissionGranted: this.props.cameraPermissionGranted,
            devices: this.props.devices,
            hasAudioOutput: this.props.hasAudioOutput,
            hasCamera: this.props.hasCamera,
            hasMicrophone: this.props.hasMicrophone,
            microphonePermissionDenied: this.props.microphonePermissionDenied,
            microphonePermissionGranted: this.props.microphonePermissionGranted,
            requestingCameraCapture: this.props.requestingCameraCapture,
            requestingCapture: this.props.requestingCapture,
            requestingMicrophoneCapture: this.props.requestingMicrophoneCapture,
            videoInput: this.props.videoInput
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function mapStateToProps$3(state, props) {
    const devices = getDevices(state).filter(device => {
        return ((!props.audioInput && !props.videoInput && !props.audioOutput) ||
            (device.kind === 'audioinput' && props.audioInput) ||
            (device.kind === 'videoinput' && props.videoInput) ||
            (device.kind === 'audiooutput' && props.audioOutput));
    });
    const permissions = getDevicePermissions(state);
    return Object.assign({}, props, { devices }, permissions);
}
function mapDispatchToProps$1(dispatch) {
    return {
        fetchDevices: () => dispatch(fetchDevices()),
        listenForDevices: () => dispatch(listenForDevices())
    };
}
var DeviceList$1 = connect$1(mapStateToProps$3, mapDispatchToProps$1)(DeviceList);

const GRID_AREAS = 'abcdefghijklmnopqrstuvwxyz';
function getGridTemplateAreas(numberOfStreams) {
    if (numberOfStreams === 1) {
        return `"a"`;
    }
    else if (numberOfStreams === 2) {
        return `"a b"`;
    }
    else if (numberOfStreams === 3) {
        return `"a b" "a c"`;
    }
    const columns = Math.ceil(Math.pow(numberOfStreams, 0.5));
    const rows = Math.ceil(numberOfStreams / columns);
    const gridTemplateRows = [];
    for (let i = 0; i < rows; i++) {
        let row = '';
        for (let j = 0; j < columns; j++) {
            row += GRID_AREAS.charAt(i * columns + j);
        }
        gridTemplateRows.push(`"${row.split('').join(' ')}"`);
    }
    return gridTemplateRows.join(' ');
}
function getGridTemplateColumns(numberOfStreams) {
    return Math.ceil(Math.pow(numberOfStreams, 0.5));
}
function getGridTemplateRows(numberOfStreams) {
    return Math.ceil(numberOfStreams / Math.ceil(Math.pow(numberOfStreams, 0.5)));
}
function getGridArea(index) {
    return GRID_AREAS.charAt(index);
}
function CellContainer(props) {
    return (createElement("div", { style: {
            display: 'flex',
            gridArea: getGridArea(props.index),
            overflow: 'hidden'
        } }, props.content));
}
function GridContainer(props) {
    return (createElement("div", { id: props.id, className: props.className, style: {
            display: 'grid',
            gridTemplateAreas: getGridTemplateAreas(props.itemCount),
            gridTemplateColumns: `repeat(${getGridTemplateColumns(props.itemCount)}, 1fr)`,
            gridTemplateRows: `repeat(${getGridTemplateRows(props.itemCount)}, 1fr)`
        } }, props.content));
}
/**
 * @description
 *
 * @public
 *
 */
class GridLayout extends Component {
    render() {
        const items = this.props.items;
        const rendered = [];
        let index = 0;
        for (const item of items) {
            const renderedItem = this.props.renderCell(item);
            if (renderedItem) {
                rendered.push(createElement(CellContainer, { index: index, key: index, content: renderedItem }));
                index += 1;
            }
        }
        return (createElement(GridContainer, { id: this.props.id, className: this.props.className, itemCount: rendered.length, content: rendered }));
    }
}

/**
 * @description
 *
 * @public
 *
 */
class LocalMediaList extends Component {
    render() {
        const renderProps = {
            audio: this.props.audio,
            media: this.props.media || [],
            removeMedia: this.props.removeMedia,
            screen: this.props.screen,
            shareLocalMedia: this.props.shareLocalMedia,
            shared: this.props.shared,
            stopSharingLocalMedia: this.props.stopSharingLocalMedia,
            video: this.props.video
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function mapStateToProps$4(state, props) {
    let desiredMedia;
    if (props.audio && !props.video) {
        desiredMedia = 'audio';
    }
    if (!props.audio && props.video) {
        desiredMedia = 'video';
    }
    let media = [];
    if (props.shared) {
        media = getSharedMedia(state, desiredMedia);
    }
    else {
        media = getLocalMedia(state, desiredMedia);
    }
    media = media.filter(m => {
        if (m.kind === 'video' && props.screen !== undefined) {
            return m.screenCapture === props.screen;
        }
        if (m.shared && props.shared === false) {
            return false;
        }
        return true;
    });
    return Object.assign({}, props, { media });
}
function mapDispatchToProps$2(dispatch) {
    return {
        removeMedia: (id) => dispatch(removeMedia(id)),
        shareLocalMedia: (id) => dispatch(shareLocalMedia(id)),
        stopSharingLocalMedia: (id) => dispatch(stopSharingLocalMedia(id))
    };
}
var LocalMediaList$1 = connect$1(mapStateToProps$4, mapDispatchToProps$2)(LocalMediaList);

/**
 * @description
 *
 * @public
 *
 */
class MediaControls extends Component {
    render() {
        const renderProps = {
            disable: this.props.disableMedia,
            enable: this.props.enableMedia,
            isEnabled: !this.props.media.localDisabled && !this.props.media.remoteDisabled,
            isShared: this.props.media.source === 'local' && !!this.props.media.shared,
            media: this.props.media,
            remove: this.props.removeLocalMedia,
            share: this.props.shareLocalMedia,
            stopSharing: () => {
                this.props.stopSharingLocalMedia();
                if (this.props.autoRemove) {
                    this.props.removeLocalMedia();
                    this.props.media.track.stop();
                }
            }
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function mapStateToProps$5(state) {
    return {};
}
function mapDispatchToProps$3(dispatch, props) {
    return {
        disableMedia: () => dispatch(disableMedia(props.media.id)),
        enableMedia: () => dispatch(enableMedia(props.media.id)),
        removeLocalMedia: () => dispatch(removeMedia(props.media.id)),
        shareLocalMedia: () => dispatch(shareLocalMedia(props.media.id)),
        stopSharingLocalMedia: () => dispatch(stopSharingLocalMedia(props.media.id))
    };
}
var MediaControls$1 = connect$1(mapStateToProps$5, mapDispatchToProps$3)(MediaControls);

/**
 * @description
 *
 * @public
 *
 */
class PeerControls extends Component {
    render() {
        const renderProps = {
            hasActiveMicrophone: this.props.hasActiveMicrophone,
            isMuted: this.props.isMuted,
            isSpeaking: this.props.isSpeaking,
            kick: this.props.kick,
            mute: this.props.mute,
            peer: this.props.peer,
            setVolumeLimit: this.props.setVolumeLimit,
            unmute: this.props.unmute
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function mapStateToProps$6(state, props) {
    const peer = getPeerByAddress(state, props.peer.address);
    const media = getMediaForPeer(state, props.peer.address, 'audio');
    const anyRemoteEnabled = media.filter(audio => !audio.remoteDisabled).length > 0;
    return {
        hasActiveMicrophone: anyRemoteEnabled,
        isMuted: peer.muted || false,
        isSpeaking: peer.speaking || false
    };
}
function mapDispatchToProps$4(dispatch, props) {
    return {
        kick: () => dispatch(kickPeer(props.peer.roomAddress, props.peer.address)),
        mute: () => dispatch(mutePeer(props.peer.address)),
        setVolumeLimit: (volume) => dispatch(limitPeerVolume(props.peer.address, volume)),
        unmute: () => dispatch(unmutePeer(props.peer.address))
    };
}
var PeerControls$1 = connect$1(mapStateToProps$6, mapDispatchToProps$4)(PeerControls);

function mapStateToProps$7(state) {
    return {
        connectionState: getConnectionState(state),
        isSupportedBrowser: isSupportedBrowser(),
        localMedia: getLocalMedia(state)
    };
}
function mapDispatchToProps$5(dispatch, props) {
    return {
        connect: () => dispatch(connect(props.configUrl, props.userData)),
        disconnect: () => dispatch(disconnect()),
        removeAllMedia: () => dispatch(removeAllMedia()),
        setDefaultValues: () => {
            if (props.desiredMedia) {
                dispatch(setDesiredMedia(props.desiredMedia));
            }
            if (props.displayName) {
                dispatch(setDisplayName(props.displayName));
            }
            if (props.videoResolutionTiers) {
                dispatch(setVideoResolutionTiers(props.videoResolutionTiers));
            }
        }
    };
}
/**
 * @description
 *
 * @public
 *
 */
class Provider extends Component {
    componentDidMount() {
        this.props.setDefaultValues();
        this.props.connect();
    }
    componentWillUnmount() {
        this.props.removeAllMedia();
        this.props.disconnect();
    }
    render() {
        const renderProps = {
            connectionState: this.props.connectionState
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function createConnectionStateComponent(connectionState) {
    return connect$1(mapStateToProps$7)(class extends Component {
        render() {
            const renderProps = {
                connectionState: this.props.connectionState
            };
            let render = this.props.render;
            if (!render && typeof this.props.children === 'function') {
                render = this.props.children;
            }
            if (this.props.connectionState === connectionState) {
                return render ? render(renderProps) : this.props.children;
            }
            return null;
        }
    });
}
/**
 * @description
 *
 * @public
 * @example
 * <NotSupported>
 *   <p>This browser does not support WebRTC media features.</p>
 * </NotSupported>
 */
const NotSupported = connect$1(mapStateToProps$7, mapDispatchToProps$5)(class extends Component {
    render() {
        if (!this.props.isSupportedBrowser) {
            return this.props.children;
        }
        return null;
    }
});
/**
 * @description
 *
 * @public
 * @example
 * <NotConnected>
 *   <p>The client is not connected. It might be connecting or disconnected.</p>
 * </NotConnected>
 */
const NotConnected = connect$1(mapStateToProps$7, mapDispatchToProps$5)(class extends Component {
    render() {
        const renderProps = {
            connectionState: this.props.connectionState
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        if (this.props.connectionState !== 'connected') {
            return render ? render(renderProps) : this.props.children;
        }
        return null;
    }
});
/**
 * @description
 * The `<Connected />` component renders its children when the SimpleWebRTC client is connected and ready.
 * @public
 * @example
 * <Connecting>
 *   <p>The client is connecting and not yet ready.</p>
 * </Connecting>
 */
const Connecting = createConnectionStateComponent('connecting');
/**
 * @description
 * The `<Connecting />` component renders its children when the SimpleWebRTC client is starting and attempting to connect to the service.
 * @public
 * @example
 * <Connected>
 *   <p>The client is now ready.</p>
 * </Connected>
 */
const Connected = createConnectionStateComponent('connected');
/**
 * @description
 * The `<Disconnected />` component renders its children when the SimpleWebRTC client has lost connection with the service.
 * @public
 * @example
 * <Disconnected>
 *   <p>The client lost access to the signaling service.</p>
 * </Disconnected>
 */
const Disconnected = createConnectionStateComponent('disconnected');
/**
 * @description
 * The `<Failed />` component renders its children when the SimpleWebRTC client failed to receive its service configuration and can not continue.
 * @public
 * @example
 * <Failed>
 *   <p>There was an error initializing the client. The service might not be available.</p>
 * </Failed>
 */
const Failed = createConnectionStateComponent('failed');
var Provider$1 = connect$1(mapStateToProps$7, mapDispatchToProps$5)(Provider);

/**
 * @description
 * The remote audio player component will play all enabled remote audio tracks. Only one instance needs to be used.
 *
 * @public
 *
 * @example
 * <div>
 *   {/* We can always keep the audio player around *\/}
 *   <RemoteAudioPlayer />
 *   <Connected>
 *     <p>Main app UI</p>
 *   </Connected>
 * </div>
 */
class RemoteAudioPlayer extends Component {
    render() {
        const sources = this.props.audioSources || [];
        const globalVolumeLimit = this.props.globalVolumeLimit;
        return (createElement(Fragment, null, sources.map(audio => (createElement(Audio, { key: audio.media.id, media: audio.media, volume: globalVolumeLimit * audio.volumeLimit, outputDevice: this.props.outputDevice })))));
    }
}
function mapStateToProps$8(state, props) {
    const media = getRemoteMedia(state, 'audio');
    const audioSources = [];
    for (const audio of media) {
        const peer = getPeerByAddress(state, audio.owner);
        audioSources.push({
            media: audio,
            volumeLimit: (peer ? peer.volumeLimit : 1) || 1
        });
    }
    return {
        audioSources,
        globalVolumeLimit: getGlobalVolumeLimit(state),
        outputDevice: getAudioOutputDevice(state)
    };
}
var RemoteAudioPlayer$1 = connect$1(mapStateToProps$8)(RemoteAudioPlayer);

/**
 * @description
 *
 * @public
 *
 */
class RemoteMediaList extends Component {
    render() {
        const renderProps = {
            audio: this.props.audio,
            media: this.props.media || [],
            peer: this.props.peer,
            video: this.props.video
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function mapStateToProps$9(state, props) {
    let desiredMedia;
    if (props.audio && !props.video) {
        desiredMedia = 'audio';
    }
    else if (!props.audio && props.video) {
        desiredMedia = 'video';
    }
    let media = [];
    if (props.peer) {
        media = getMediaForPeer(state, props.peer, desiredMedia);
    }
    else {
        media = getRemoteMedia(state, desiredMedia);
    }
    return Object.assign({}, props, { media });
}
var RemoteMediaList$1 = connect$1(mapStateToProps$9)(RemoteMediaList);

/**
 * @description
 *
 * @public
 *
 */
class RequestDisplayMedia extends Component {
    constructor(props) {
        super(props);
        this.installCheckInterval = undefined;
        this.state = {
            extensionInstalled: this.props.extensionId
                ? checkForExtensionSync(this.props.extensionId)
                : false,
            extensionInstalling: false,
            extensionRequired: requiresExtension()
        };
    }
    componentDidMount() {
        if (requiresExtension() && this.props.extensionId) {
            checkForExtension(this.props.extensionId).then(extensionInstalled => {
                this.setState({
                    extensionInstalled
                });
            });
        }
    }
    getDisplayMedia() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!navigator.mediaDevices.getDisplayMedia) {
                    throw new Error('getDisplayMedia not supported');
                }
                const stream = yield navigator.mediaDevices.getDisplayMedia({ video: true });
                const track = stream.getVideoTracks()[0];
                this.props.addLocalScreen(track, stream);
                if (this.props.share !== false) {
                    this.props.shareLocalScreen(track.id);
                }
            }
            catch (err) {
                console.log(err, err.message, err.name);
            }
        });
    }
    listenForInstallation(interval = 2000) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.installCheckInterval) {
                clearInterval(this.installCheckInterval);
                this.installCheckInterval = undefined;
            }
            this.setState({
                extensionInstalling: true
            });
            this.installCheckInterval = setInterval(() => {
                if (!this.props.extensionId || this.state.extensionInstalled) {
                    clearInterval(this.installCheckInterval);
                    this.installCheckInterval = undefined;
                    return;
                }
                checkForExtension(this.props.extensionId).then(extensionInstalled => {
                    this.setState({
                        extensionInstalled,
                        extensionInstalling: !extensionInstalled
                    });
                });
            }, interval);
        });
    }
    render() {
        if (this.props.render) {
            const available = isAvailable();
            const ready = available &&
                (!this.state.extensionRequired ||
                    (this.state.extensionRequired && this.state.extensionInstalled));
            return this.props.render(this.getDisplayMedia.bind(this), {
                available,
                extensionId: this.props.extensionId,
                extensionInstalled: this.state.extensionInstalled,
                extensionInstalling: this.state.extensionInstalling,
                extensionRequired: this.state.extensionRequired,
                listenForInstallation: this.listenForInstallation.bind(this),
                ready
            });
        }
        return createElement("button", { onClick: () => this.getDisplayMedia() }, "Start Screenshare");
    }
}
function mapStateToProps$a(state, ownProps) {
    const config = getAPIConfig(state);
    return {
        extensionId: ownProps.extensionId || config.screensharingExtensions.chrome
    };
}
function mapDispatchToProps$6(dispatch) {
    return {
        addLocalScreen: (track, stream) => dispatch(addLocalScreen(track, stream)),
        shareLocalScreen: (id) => dispatch(shareLocalMedia(id))
    };
}
var RequestDisplayMedia$1 = connect$1(mapStateToProps$a, mapDispatchToProps$6)(RequestDisplayMedia);

function mergeConstraints(defaults, provided, additional) {
    const disabled = additional === false || (!additional && !provided);
    if (disabled) {
        return false;
    }
    provided = provided === true ? {} : provided;
    additional = additional === true ? {} : additional;
    return Object.assign({}, defaults, provided, additional);
}
/**
 * @description
 * The `<RequestUserMedia />` component can be used to request user audio and video media.
 *
 * @public
 *
 * @example
 * <div>
 *   {/* Request audio and immediately share *\/}
 *   <RequestUserMedia audio auto share />
 *   {/* Request audio and video, but use custom renderer to trigger it *\/}
 *   <RequestUserMedia audio video share
 *    render={({ getUserMedia }) => (
 *    <button onClick={getUserMedia}>Get Media</button>
 *   )} />
 * </div>
 */
class RequestUserMedia extends Component {
    constructor(props) {
        super(props);
        this.errorCount = 0;
    }
    getMedia(additional = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let stream;
            const defaultAudioConstraints = {};
            const audioConstraints = mergeConstraints(defaultAudioConstraints, this.props.audio, additional.audio);
            const videoConstraints = mergeConstraints({}, this.props.video, additional.video);
            try {
                if (!navigator.mediaDevices) {
                    throw new Error('getUserMedia not supported');
                }
                this.props.deviceCaptureRequest(!!videoConstraints, !!audioConstraints);
                if (audioConstraints) {
                    // Multiple browser implementations only allow capturing one audio source at a time.
                    // As such, we stop all existing audio captures before requesting a new one.
                    yield this.props.removeAllMedia('audio');
                }
                stream = yield navigator.mediaDevices.getUserMedia({
                    audio: audioConstraints,
                    video: videoConstraints
                });
            }
            catch (err) {
                this.errorCount += 1;
                if (err.name === 'AbortError' && this.errorCount < 12) {
                    // We still sometimes can't start new audio after recently ending previous
                    // audio. So we will try to attempt the request again a few times.
                    setTimeout(() => this.getMedia(additional), 100 + Math.pow(2, this.errorCount));
                    return {};
                }
                if (err.name === 'NotAllowedError' || err.name === 'SecurityError') {
                    if (!!audioConstraints) {
                        this.props.microphonePermissionDenied();
                    }
                    if (!!videoConstraints) {
                        this.props.cameraPermissionDenied();
                    }
                }
                this.props.deviceCaptureRequest(false, false);
                if (this.props.onError) {
                    this.props.onError(err);
                }
                return {};
            }
            this.errorCount = 0;
            const audio = stream.getAudioTracks()[0];
            const video = stream.getVideoTracks()[0];
            if (audio) {
                this.props.addLocalAudio(audio, stream, this.props.replaceAudio);
                if (this.props.share !== false) {
                    this.props.shareLocalMedia(audio.id);
                }
            }
            else if (!!audioConstraints) {
                this.props.microphonePermissionDenied();
            }
            if (video) {
                if (this.props.screenCapture) {
                    this.props.addLocalScreen(video, stream, this.props.replaceVideo);
                }
                else {
                    this.props.addLocalVideo(video, stream, this.props.mirrored, this.props.replaceVideo);
                }
                if (this.props.share !== false) {
                    this.props.shareLocalMedia(video.id);
                }
            }
            else if (!!videoConstraints) {
                this.props.cameraPermissionDenied();
            }
            yield this.props.fetchDevices();
            yield this.props.deviceCaptureRequest(false, false);
            const trackIds = {
                audio: audio ? audio.id : undefined,
                video: video ? video.id : undefined
            };
            if (this.props.onSuccess) {
                this.props.onSuccess(trackIds);
            }
            return trackIds;
        });
    }
    componentDidMount() {
        if (this.props.auto) {
            this.getMedia();
        }
    }
    componentDidUpdate(prevProps) {
        if (this.props.auto && this.props.auto !== prevProps.auto) {
            this.getMedia();
        }
    }
    render() {
        const renderProps = this.getMedia.bind(this);
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        if (render) {
            return render(renderProps);
        }
        else if (this.props.children) {
            return this.props.children;
        }
        if (this.props.auto) {
            return null;
        }
        else {
            return createElement("button", { onClick: renderProps }, "Request Media");
        }
    }
}
function mapStateToProps$b(state, props) {
    const permissions = getDevicePermissions(state);
    return Object.assign({}, props, { requestingCameraCapture: permissions.requestingCameraCapture, requestingCapture: permissions.requestingCapture, requestingMicrophoneCapture: permissions.requestingMicrophoneCapture });
}
function mapDispatchToProps$7(dispatch) {
    return {
        addLocalAudio: (track, stream, replace) => dispatch(addLocalAudio(track, stream, replace)),
        addLocalScreen: (track, stream, replace) => dispatch(addLocalScreen(track, stream, replace)),
        addLocalVideo: (track, stream, mirrored, replace) => dispatch(addLocalVideo(track, stream, mirrored, replace)),
        cameraPermissionDenied: (err) => dispatch(cameraPermissionDenied(err)),
        deviceCaptureRequest: (camera, microphone) => dispatch(deviceCaptureRequest(camera, microphone)),
        fetchDevices: () => dispatch(fetchDevices()),
        microphonePermissionDenied: (err) => dispatch(microphonePermissionDenied(err)),
        removeAllMedia: (kind) => dispatch(removeAllMedia(kind)),
        shareLocalMedia: (id) => dispatch(shareLocalMedia(id))
    };
}
var RequestUserMedia$1 = connect$1(mapStateToProps$b, mapDispatchToProps$7)(RequestUserMedia);

/**
 * @description
 *
 * @public
 *
 */
class Room extends Component {
    componentDidMount() {
        if (this.props.connectionState === 'connected') {
            this.props.join();
        }
    }
    componentWillUnmount() {
        this.props.leave(this.props.roomAddress);
    }
    componentDidUpdate(prevProps) {
        if (this.props.connectionState !== 'connected') {
            return;
        }
        if (this.props.connectionState !== prevProps.connectionState) {
            this.props.join();
            return;
        }
        if (!this.props.room) {
            return;
        }
        if (this.props.password !== prevProps.password) {
            if (this.props.room.roomState === 'joined') {
                if (this.props.password) {
                    this.props.lock(this.props.roomAddress, this.props.password);
                }
                else {
                    this.props.unlock(this.props.roomAddress);
                }
            }
            else {
                this.props.join();
            }
        }
    }
    render() {
        const renderProps = {
            call: this.props.call || {},
            joined: this.props.room ? this.props.room.joined : false,
            localMedia: this.props.localMedia || [],
            peers: this.props.peers || [],
            remoteMedia: this.props.remoteMedia || [],
            room: this.props.room || {}
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        return render ? render(renderProps) : this.props.children;
    }
}
function mapStateToProps$c(state, props) {
    let room;
    if (props.roomAddress) {
        room = getRoomByAddress(state, props.roomAddress);
    }
    else if (props.name) {
        room = getRoomByProvidedName(state, props.name);
    }
    return {
        call: room ? getCallForRoom(state, room.address) : undefined,
        connectionState: getConnectionState(state),
        localMedia: getLocalMedia(state),
        peers: room ? getPeersForRoom(state, room.address) : [],
        remoteMedia: getRemoteMedia(state),
        room,
        roomAddress: room ? room.address : undefined,
        roomState: room ? room.roomState : 'joining'
    };
}
function mapDispatchToProps$8(dispatch, props) {
    return {
        destroy: (roomAddress) => dispatch(destroyRoom(roomAddress)),
        join: () => dispatch(joinRoom(props.name, { password: props.password || undefined })),
        leave: (roomAddress) => dispatch(leaveRoom(roomAddress)),
        lock: (roomAddress, password) => dispatch(lockRoom(roomAddress, password)),
        unlock: (roomAddress) => dispatch(unlockRoom(roomAddress))
    };
}
var Room$1 = connect$1(mapStateToProps$c, mapDispatchToProps$8)(Room);

/**
 * @description
 *
 * @public
 *
 */
class UserControls extends Component {
    render() {
        const renderProps = {
            customerData: this.props.customerData || {},
            deafen: this.props.deafen,
            isDeafened: this.props.isDeafened || false,
            isMuted: this.props.isMuted || false,
            isPaused: this.props.isPaused || false,
            isSpeaking: this.props.isSpeaking || false,
            isSpeakingWhileMuted: this.props.isSpeakingWhileMuted || false,
            mute: this.props.mute,
            pauseVideo: this.props.pauseVideo,
            resumeVideo: this.props.resumeVideo,
            setAudioOutputDevice: this.props.setAudioOutputDevice,
            setDisplayName: this.props.setDisplayName,
            setGlobalVolumeLimit: this.props.setGlobalVolumeLimit,
            setVoiceActivityThreshold: this.props.setVoiceActivityThreshold,
            undeafen: this.props.undeafen,
            unmute: this.props.unmute,
            user: this.props.user
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        if (render) {
            return render(renderProps);
        }
        return this.props.children;
    }
}
function mapStateToProps$d(state, props) {
    const enabledAudioMedia = getLocalMedia(state, 'audio').filter(audio => !audio.localDisabled);
    const enabledVideoMedia = getLocalMedia(state, 'video').filter(video => !video.localDisabled);
    const customerData = getUserCustomerData(state);
    const user = getUser(state);
    const globalVolumeLimit = getGlobalVolumeLimit(state);
    const isSpeaking = userIsSpeaking(state, false);
    const isSpeakingWhileMuted = userIsSpeakingWhileMuted(state, false);
    return {
        customerData,
        isDeafened: globalVolumeLimit === 0,
        isMuted: !enabledAudioMedia.length,
        isPaused: !enabledVideoMedia.length,
        isSpeaking,
        isSpeakingWhileMuted,
        user
    };
}
function mapDispatchToProps$9(dispatch, props) {
    return {
        deafen: () => dispatch(setGlobalVolumeLimit(0)),
        mute: () => dispatch(muteSelf()),
        pauseVideo: () => dispatch(pauseSelfVideo()),
        resumeVideo: () => dispatch(resumeSelfVideo()),
        setAudioOutputDevice: (deviceId) => dispatch(setAudioOutputDevice(deviceId)),
        setDisplayName: (name) => dispatch(setDisplayName(name)),
        setGlobalVolumeLimit: (volumeLimit) => dispatch(setGlobalVolumeLimit(volumeLimit)),
        setVoiceActivityThreshold: (threshold) => dispatch(setVoiceActivityThreshold(threshold)),
        undeafen: () => dispatch(setGlobalVolumeLimit(1)),
        unmute: () => dispatch(unmuteSelf())
    };
}
var UserControls$1 = connect$1(mapStateToProps$d, mapDispatchToProps$9)(UserControls);

/**
 * @description
 * Local and remote video tracks can be played with the `<Video/>` component.
 *
 * The provided `media` property can include `remoteDisabled` and `localDisabled` fields. If either of those properties are `true`, video playback will be paused.
 *
 * @public
 *
 * @example
 * <Video media={getMediaTrack(store, 'some-media-id')} />
 */
class Video extends Component {
    componentDidMount() {
        this.setup();
    }
    componentDidUpdate(prev) {
        this.setup();
    }
    setup() {
        if (!this.props.media || !this.video) {
            return;
        }
        this.video.oncontextmenu = e => {
            e.preventDefault();
        };
        this.video.muted = true;
        this.video.autoplay = true;
        if (this.video.srcObject !== this.props.media.stream) {
            this.video.srcObject = this.props.media.stream;
        }
    }
    render() {
        if (!this.props.media || !this.props.media.loaded) {
            return null;
        }
        return (createElement("video", { ref: (el) => {
                this.video = el;
            }, style: this.props.media && this.props.media.renderMirrored
                ? {
                    transform: 'scaleX(-1)'
                }
                : {}, playsInline: true }));
    }
}

/**
 * @description
 * The volume meter component can be used to display the audio output volume of a track. Useful for showing that a user's microphone is live and sensitive enough to detect speech.
 *
 * @public
 *
 * @example
 * <VolumeMeter
 * media={getMediaTrack(store, 'some-media-id')}
 * render={({ volume, speaking }) => {
 *   // Render volume as a series of segments
 *
 *   const buckets = Math.abs(Math.max(volume / 10));
 *   let i = 0;
 *
 *   const segments = [];
 *   for (let i = 0; i < buckets; i++) {
 *       segments.push(<div key={i} className='volume-meter-segment' />);
 *   }
 *
 *   return (
 *     <div className={speaking ? 'volume-meter-speaking' : 'volume-meter-notspeaking'}>
 *       {segments}
 *     </div>
 *   );
 * }} />
 */
class VolumeMeter extends Component {
    constructor(props) {
        super(props);
        this.state = {
            volume: -Infinity
        };
        this.onVolume = (volume) => {
            this.setState({
                volume
            });
        };
    }
    componentDidMount() {
        if (!this.props.media || !this.props.media.hark) {
            return;
        }
        this.attachHark();
    }
    componentWillUnmount() {
        this.detachHark();
    }
    componentDidUpdate(prevProps) {
        if (prevProps.media !== this.props.media) {
            this.detachHark();
            this.attachHark();
        }
    }
    attachHark() {
        this.setState({
            volume: -Infinity
        });
        if (this.props.media) {
            this.hark = this.props.media.hark;
        }
        if (this.hark) {
            this.hark.on('volume', this.onVolume);
        }
    }
    detachHark() {
        if (this.hark) {
            this.hark.removeListener('volume', this.onVolume);
            this.hark = undefined;
        }
        this.setState({
            volume: -Infinity
        });
    }
    render() {
        const media = this.props.media;
        const noInputTimeout = this.props.noInputTimeout || 7000;
        const noInput = media &&
            (media.externalDisabled ||
                (!!media.inputLost && Date.now() - media.inputLost > noInputTimeout));
        const renderProps = {
            loaded: media && !!media.loaded && !!media.inputDetected,
            media,
            muted: media && media.localDisabled,
            noInput,
            speaking: media && media.speaking,
            speakingWhileMuted: media && media.localDisabled && media.speaking,
            volume: media.externalDisabled ? -Infinity : this.state.volume
        };
        let render = this.props.render;
        if (!render && typeof this.props.children === 'function') {
            render = this.props.children;
        }
        if (render) {
            return render(renderProps);
        }
        return this.props.children;
    }
}

const isSupportedBrowser$1 = isSupportedBrowser();
const screensharing = ScreenSharingHelpers;
const initial = {
    simplewebrtc: {}
};
function createStore() {
    return createStore$1(combineReducers({
        simplewebrtc: reducer
    }), initial, compose(applyMiddleware(Thunk)));
}

export { index as Actions, Audio, ChatComposers, ChatInput$1 as ChatInput, ChatList$1 as ChatList, Connected, Connecting, DeviceList$1 as DeviceList, Disconnected, Failed, GridLayout, LocalMediaList$1 as LocalMediaList, MediaControls$1 as MediaControls, NotConnected, NotSupported, PeerControls$1 as PeerControls, PeerList$1 as PeerList, Provider$1 as Provider, RemoteAudioPlayer$1 as RemoteAudioPlayer, RemoteMediaList$1 as RemoteMediaList, RequestDisplayMedia$1 as RequestDisplayMedia, RequestUserMedia$1 as RequestUserMedia, Room$1 as Room, Selectors, StayDownContainer, UserControls$1 as UserControls, Video, VolumeMeter, createStore, isSupportedBrowser$1 as isSupportedBrowser, reducer, screensharing };
